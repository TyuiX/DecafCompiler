Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    ERROR
    LBRACKET
    RBRACKET

Grammar

Rule 0     S' -> start
Rule 1     start -> start_statement
Rule 2     start -> empty
Rule 3     start_statement -> class_decl
Rule 4     start_statement -> class_decl start_statement
Rule 5     class_decl -> CLASS ID LCURLY class_body RCURLY
Rule 6     class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY
Rule 7     class_body -> field_decl
Rule 8     class_body -> constructor_decl
Rule 9     class_body -> method_decl
Rule 10    class_body -> class_body field_decl
Rule 11    class_body -> class_body constructor_decl
Rule 12    class_body -> class_body method_decl
Rule 13    field_decl -> var_decl
Rule 14    field_decl -> modifier var_decl
Rule 15    modifier -> PUBLIC
Rule 16    modifier -> PRIVATE
Rule 17    modifier -> STATIC
Rule 18    modifier -> PUBLIC STATIC
Rule 19    modifier -> PRIVATE STATIC
Rule 20    modifier -> empty
Rule 21    var_decl -> type variables SEMICOLON
Rule 22    type -> INT
Rule 23    type -> FLOAT
Rule 24    type -> BOOLEAN
Rule 25    type -> STRING
Rule 26    type -> ID
Rule 27    variables -> variable
Rule 28    variables -> variables COMMA variable
Rule 29    variable -> ID
Rule 30    method_decl -> modifier type ID LPAREN RPAREN block
Rule 31    method_decl -> modifier type ID LPAREN formals RPAREN block
Rule 32    method_decl -> modifier VOID ID LPAREN RPAREN block
Rule 33    method_decl -> modifier VOID ID LPAREN formals RPAREN block
Rule 34    method_decl -> type ID LPAREN RPAREN block
Rule 35    method_decl -> type ID LPAREN formals RPAREN block
Rule 36    method_decl -> VOID ID LPAREN RPAREN block
Rule 37    method_decl -> VOID ID LPAREN formals RPAREN block
Rule 38    constructor_decl -> modifier ID LPAREN RPAREN block
Rule 39    constructor_decl -> modifier ID LPAREN formals RPAREN block
Rule 40    constructor_decl -> ID LPAREN RPAREN block
Rule 41    constructor_decl -> ID LPAREN formals RPAREN block
Rule 42    formals -> formal_param
Rule 43    formals -> formal_param COMMA formals
Rule 44    formal_param -> type variable
Rule 45    block -> LCURLY stmtlist RCURLY
Rule 46    block -> empty
Rule 47    stmtlist -> stmt
Rule 48    stmtlist -> stmtlist stmt
Rule 49    stmt -> IF LPAREN expression RPAREN stmt
Rule 50    stmt -> IF LPAREN expression RPAREN stmt ELSE stmt
Rule 51    stmt -> WHILE LPAREN expression RPAREN stmt
Rule 52    stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
Rule 53    stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
Rule 54    stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
Rule 55    stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
Rule 56    stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
Rule 57    stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
Rule 58    stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
Rule 59    stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
Rule 60    stmt -> RETURN expression SEMICOLON
Rule 61    stmt -> RETURN SEMICOLON
Rule 62    stmt -> stmt_expression SEMICOLON
Rule 63    stmt -> BREAK SEMICOLON
Rule 64    stmt -> CONTINUE SEMICOLON
Rule 65    stmt -> block
Rule 66    stmt -> var_decl
Rule 67    stmt -> SEMICOLON
Rule 68    literal -> INTEGER
Rule 69    literal -> FLOAT
Rule 70    literal -> STRING_LITERAL
Rule 71    literal -> NULL
Rule 72    literal -> FALSE
Rule 73    literal -> TRUE
Rule 74    primary -> literal
Rule 75    primary -> THIS
Rule 76    primary -> SUPER
Rule 77    primary -> LPAREN expression RPAREN
Rule 78    primary -> NEW ID LPAREN RPAREN
Rule 79    primary -> NEW ID LPAREN arguments RPAREN
Rule 80    primary -> method_invocation
Rule 81    primary -> lhs
Rule 82    arguments -> expression
Rule 83    arguments -> expression COMMA arguments
Rule 84    lhs -> field_access
Rule 85    field_access -> primary DOT ID
Rule 86    field_access -> ID
Rule 87    method_invocation -> field_access LPAREN arguments RPAREN
Rule 88    method_invocation -> field_access LPAREN RPAREN
Rule 89    expression -> primary
Rule 90    expression -> assign
Rule 91    expression -> expression arith_op expression
Rule 92    expression -> expression bool_op expression
Rule 93    expression -> unary_op expression
Rule 94    operation -> expression arith_op expression
Rule 95    operation -> expression bool_op expression
Rule 96    assign -> lhs SETEQUAL expression
Rule 97    assign -> lhs PLUSPLUS
Rule 98    assign -> lhs MINUSMINUS
Rule 99    assign -> PLUSPLUS lhs
Rule 100   assign -> MINUSMINUS lhs
Rule 101   arith_op -> PLUS
Rule 102   arith_op -> MINUS
Rule 103   arith_op -> TIMES
Rule 104   arith_op -> DIVIDE
Rule 105   bool_op -> GREATER
Rule 106   bool_op -> LESS
Rule 107   bool_op -> GREATEREQ
Rule 108   bool_op -> LESSEQ
Rule 109   bool_op -> EQUAL
Rule 110   bool_op -> NOTEQUAL
Rule 111   bool_op -> AND
Rule 112   bool_op -> OR
Rule 113   unary_op -> PLUS
Rule 114   unary_op -> MINUS
Rule 115   unary_op -> NOT
Rule 116   stmt_expression -> assign
Rule 117   stmt_expression -> method_invocation
Rule 118   empty -> <empty>

Terminals, with rules where they appear

AND                  : 111
BOOLEAN              : 24
BREAK                : 63
CLASS                : 5 6
COMMA                : 28 43 83
CONTINUE             : 64
DIVIDE               : 104
DO                   : 
DOT                  : 85
ELSE                 : 50
EQUAL                : 109
ERROR                : 
EXTENDS              : 6
FALSE                : 72
FLOAT                : 23 69
FOR                  : 52 53 54 55 56 57 58 59
GREATER              : 105
GREATEREQ            : 107
ID                   : 5 6 6 26 29 30 31 32 33 34 35 36 37 38 39 40 41 78 79 85 86
IF                   : 49 50
INT                  : 22
INTEGER              : 68
LBRACKET             : 
LCURLY               : 5 6 45
LESS                 : 106
LESSEQ               : 108
LPAREN               : 30 31 32 33 34 35 36 37 38 39 40 41 49 50 51 52 53 54 55 56 57 58 59 77 78 79 87 88
MINUS                : 102 114
MINUSMINUS           : 98 100
NEW                  : 78 79
NOT                  : 115
NOTEQUAL             : 110
NULL                 : 71
OR                   : 112
PLUS                 : 101 113
PLUSPLUS             : 97 99
PRIVATE              : 16 19
PUBLIC               : 15 18
RBRACKET             : 
RCURLY               : 5 6 45
RETURN               : 60 61
RPAREN               : 30 31 32 33 34 35 36 37 38 39 40 41 49 50 51 52 53 54 55 56 57 58 59 77 78 79 87 88
SEMICOLON            : 21 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 61 62 63 64 67
SETEQUAL             : 96
STATIC               : 17 18 19
STRING               : 25
STRING_LITERAL       : 70
SUPER                : 76
THIS                 : 75
TIMES                : 103
TRUE                 : 73
VOID                 : 32 33 36 37
WHILE                : 51
error                : 

Nonterminals, with rules where they appear

arguments            : 79 83 87
arith_op             : 91 94
assign               : 90 116
block                : 30 31 32 33 34 35 36 37 38 39 40 41 65
bool_op              : 92 95
class_body           : 5 6 10 11 12
class_decl           : 3 4
constructor_decl     : 8 11
empty                : 2 20 46
expression           : 49 50 51 52 53 55 58 60 77 82 83 91 91 92 92 93 94 94 95 95 96
field_access         : 84 87 88
field_decl           : 7 10
formal_param         : 42 43
formals              : 31 33 35 37 39 41 43
lhs                  : 81 96 97 98 99 100
literal              : 74
method_decl          : 9 12
method_invocation    : 80 117
modifier             : 14 30 31 32 33 38 39
operation            : 
primary              : 85 89
start                : 0
start_statement      : 1 4
stmt                 : 47 48 49 50 50 51 52 53 54 55 56 57 58 59
stmt_expression      : 52 52 53 54 54 55 56 57 62
stmtlist             : 45 48
type                 : 21 30 31 34 35 44
unary_op             : 93
var_decl             : 13 14 66
variable             : 27 28 44
variables            : 21 28

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . start_statement
    (2) start -> . empty
    (3) start_statement -> . class_decl
    (4) start_statement -> . class_decl start_statement
    (118) empty -> .
    (5) class_decl -> . CLASS ID LCURLY class_body RCURLY
    (6) class_decl -> . CLASS ID EXTENDS ID LCURLY class_body RCURLY

    $end            reduce using rule 118 (empty -> .)
    CLASS           shift and go to state 5

    start                          shift and go to state 1
    start_statement                shift and go to state 2
    empty                          shift and go to state 3
    class_decl                     shift and go to state 4

state 1

    (0) S' -> start .



state 2

    (1) start -> start_statement .

    $end            reduce using rule 1 (start -> start_statement .)


state 3

    (2) start -> empty .

    $end            reduce using rule 2 (start -> empty .)


state 4

    (3) start_statement -> class_decl .
    (4) start_statement -> class_decl . start_statement
    (3) start_statement -> . class_decl
    (4) start_statement -> . class_decl start_statement
    (5) class_decl -> . CLASS ID LCURLY class_body RCURLY
    (6) class_decl -> . CLASS ID EXTENDS ID LCURLY class_body RCURLY

    $end            reduce using rule 3 (start_statement -> class_decl .)
    CLASS           shift and go to state 5

    class_decl                     shift and go to state 4
    start_statement                shift and go to state 6

state 5

    (5) class_decl -> CLASS . ID LCURLY class_body RCURLY
    (6) class_decl -> CLASS . ID EXTENDS ID LCURLY class_body RCURLY

    ID              shift and go to state 7


state 6

    (4) start_statement -> class_decl start_statement .

    $end            reduce using rule 4 (start_statement -> class_decl start_statement .)


state 7

    (5) class_decl -> CLASS ID . LCURLY class_body RCURLY
    (6) class_decl -> CLASS ID . EXTENDS ID LCURLY class_body RCURLY

    LCURLY          shift and go to state 8
    EXTENDS         shift and go to state 9


state 8

    (5) class_decl -> CLASS ID LCURLY . class_body RCURLY
    (7) class_body -> . field_decl
    (8) class_body -> . constructor_decl
    (9) class_body -> . method_decl
    (10) class_body -> . class_body field_decl
    (11) class_body -> . class_body constructor_decl
    (12) class_body -> . class_body method_decl
    (13) field_decl -> . var_decl
    (14) field_decl -> . modifier var_decl
    (38) constructor_decl -> . modifier ID LPAREN RPAREN block
    (39) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (40) constructor_decl -> . ID LPAREN RPAREN block
    (41) constructor_decl -> . ID LPAREN formals RPAREN block
    (30) method_decl -> . modifier type ID LPAREN RPAREN block
    (31) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (32) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (33) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (34) method_decl -> . type ID LPAREN RPAREN block
    (35) method_decl -> . type ID LPAREN formals RPAREN block
    (36) method_decl -> . VOID ID LPAREN RPAREN block
    (37) method_decl -> . VOID ID LPAREN formals RPAREN block
    (21) var_decl -> . type variables SEMICOLON
    (15) modifier -> . PUBLIC
    (16) modifier -> . PRIVATE
    (17) modifier -> . STATIC
    (18) modifier -> . PUBLIC STATIC
    (19) modifier -> . PRIVATE STATIC
    (20) modifier -> . empty
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (118) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 10
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 19
    PRIVATE         shift and go to state 20
    STATIC          shift and go to state 21
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26

  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! VOID            [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]

    class_body                     shift and go to state 11
    field_decl                     shift and go to state 12
    constructor_decl               shift and go to state 13
    method_decl                    shift and go to state 14
    var_decl                       shift and go to state 15
    modifier                       shift and go to state 16
    type                           shift and go to state 17
    empty                          shift and go to state 22

state 9

    (6) class_decl -> CLASS ID EXTENDS . ID LCURLY class_body RCURLY

    ID              shift and go to state 27


state 10

    (40) constructor_decl -> ID . LPAREN RPAREN block
    (41) constructor_decl -> ID . LPAREN formals RPAREN block
    (26) type -> ID .

    LPAREN          shift and go to state 28
    ID              reduce using rule 26 (type -> ID .)


state 11

    (5) class_decl -> CLASS ID LCURLY class_body . RCURLY
    (10) class_body -> class_body . field_decl
    (11) class_body -> class_body . constructor_decl
    (12) class_body -> class_body . method_decl
    (13) field_decl -> . var_decl
    (14) field_decl -> . modifier var_decl
    (38) constructor_decl -> . modifier ID LPAREN RPAREN block
    (39) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (40) constructor_decl -> . ID LPAREN RPAREN block
    (41) constructor_decl -> . ID LPAREN formals RPAREN block
    (30) method_decl -> . modifier type ID LPAREN RPAREN block
    (31) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (32) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (33) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (34) method_decl -> . type ID LPAREN RPAREN block
    (35) method_decl -> . type ID LPAREN formals RPAREN block
    (36) method_decl -> . VOID ID LPAREN RPAREN block
    (37) method_decl -> . VOID ID LPAREN formals RPAREN block
    (21) var_decl -> . type variables SEMICOLON
    (15) modifier -> . PUBLIC
    (16) modifier -> . PRIVATE
    (17) modifier -> . STATIC
    (18) modifier -> . PUBLIC STATIC
    (19) modifier -> . PRIVATE STATIC
    (20) modifier -> . empty
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (118) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    RCURLY          shift and go to state 29
    ID              shift and go to state 10
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 19
    PRIVATE         shift and go to state 20
    STATIC          shift and go to state 21
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26

  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! VOID            [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]

    field_decl                     shift and go to state 30
    constructor_decl               shift and go to state 31
    method_decl                    shift and go to state 32
    var_decl                       shift and go to state 15
    modifier                       shift and go to state 16
    type                           shift and go to state 17
    empty                          shift and go to state 22

state 12

    (7) class_body -> field_decl .

    RCURLY          reduce using rule 7 (class_body -> field_decl .)
    ID              reduce using rule 7 (class_body -> field_decl .)
    VOID            reduce using rule 7 (class_body -> field_decl .)
    PUBLIC          reduce using rule 7 (class_body -> field_decl .)
    PRIVATE         reduce using rule 7 (class_body -> field_decl .)
    STATIC          reduce using rule 7 (class_body -> field_decl .)
    INT             reduce using rule 7 (class_body -> field_decl .)
    FLOAT           reduce using rule 7 (class_body -> field_decl .)
    BOOLEAN         reduce using rule 7 (class_body -> field_decl .)
    STRING          reduce using rule 7 (class_body -> field_decl .)


state 13

    (8) class_body -> constructor_decl .

    RCURLY          reduce using rule 8 (class_body -> constructor_decl .)
    ID              reduce using rule 8 (class_body -> constructor_decl .)
    VOID            reduce using rule 8 (class_body -> constructor_decl .)
    PUBLIC          reduce using rule 8 (class_body -> constructor_decl .)
    PRIVATE         reduce using rule 8 (class_body -> constructor_decl .)
    STATIC          reduce using rule 8 (class_body -> constructor_decl .)
    INT             reduce using rule 8 (class_body -> constructor_decl .)
    FLOAT           reduce using rule 8 (class_body -> constructor_decl .)
    BOOLEAN         reduce using rule 8 (class_body -> constructor_decl .)
    STRING          reduce using rule 8 (class_body -> constructor_decl .)


state 14

    (9) class_body -> method_decl .

    RCURLY          reduce using rule 9 (class_body -> method_decl .)
    ID              reduce using rule 9 (class_body -> method_decl .)
    VOID            reduce using rule 9 (class_body -> method_decl .)
    PUBLIC          reduce using rule 9 (class_body -> method_decl .)
    PRIVATE         reduce using rule 9 (class_body -> method_decl .)
    STATIC          reduce using rule 9 (class_body -> method_decl .)
    INT             reduce using rule 9 (class_body -> method_decl .)
    FLOAT           reduce using rule 9 (class_body -> method_decl .)
    BOOLEAN         reduce using rule 9 (class_body -> method_decl .)
    STRING          reduce using rule 9 (class_body -> method_decl .)


state 15

    (13) field_decl -> var_decl .

    RCURLY          reduce using rule 13 (field_decl -> var_decl .)
    ID              reduce using rule 13 (field_decl -> var_decl .)
    VOID            reduce using rule 13 (field_decl -> var_decl .)
    PUBLIC          reduce using rule 13 (field_decl -> var_decl .)
    PRIVATE         reduce using rule 13 (field_decl -> var_decl .)
    STATIC          reduce using rule 13 (field_decl -> var_decl .)
    INT             reduce using rule 13 (field_decl -> var_decl .)
    FLOAT           reduce using rule 13 (field_decl -> var_decl .)
    BOOLEAN         reduce using rule 13 (field_decl -> var_decl .)
    STRING          reduce using rule 13 (field_decl -> var_decl .)


state 16

    (14) field_decl -> modifier . var_decl
    (38) constructor_decl -> modifier . ID LPAREN RPAREN block
    (39) constructor_decl -> modifier . ID LPAREN formals RPAREN block
    (30) method_decl -> modifier . type ID LPAREN RPAREN block
    (31) method_decl -> modifier . type ID LPAREN formals RPAREN block
    (32) method_decl -> modifier . VOID ID LPAREN RPAREN block
    (33) method_decl -> modifier . VOID ID LPAREN formals RPAREN block
    (21) var_decl -> . type variables SEMICOLON
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID

    ID              shift and go to state 34
    VOID            shift and go to state 36
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26

    var_decl                       shift and go to state 33
    type                           shift and go to state 35

state 17

    (34) method_decl -> type . ID LPAREN RPAREN block
    (35) method_decl -> type . ID LPAREN formals RPAREN block
    (21) var_decl -> type . variables SEMICOLON
    (27) variables -> . variable
    (28) variables -> . variables COMMA variable
    (29) variable -> . ID

    ID              shift and go to state 37

    variables                      shift and go to state 38
    variable                       shift and go to state 39

state 18

    (36) method_decl -> VOID . ID LPAREN RPAREN block
    (37) method_decl -> VOID . ID LPAREN formals RPAREN block

    ID              shift and go to state 40


state 19

    (15) modifier -> PUBLIC .
    (18) modifier -> PUBLIC . STATIC

    ID              reduce using rule 15 (modifier -> PUBLIC .)
    VOID            reduce using rule 15 (modifier -> PUBLIC .)
    INT             reduce using rule 15 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 15 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 15 (modifier -> PUBLIC .)
    STRING          reduce using rule 15 (modifier -> PUBLIC .)
    STATIC          shift and go to state 41


state 20

    (16) modifier -> PRIVATE .
    (19) modifier -> PRIVATE . STATIC

    ID              reduce using rule 16 (modifier -> PRIVATE .)
    VOID            reduce using rule 16 (modifier -> PRIVATE .)
    INT             reduce using rule 16 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 16 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 16 (modifier -> PRIVATE .)
    STRING          reduce using rule 16 (modifier -> PRIVATE .)
    STATIC          shift and go to state 42


state 21

    (17) modifier -> STATIC .

    ID              reduce using rule 17 (modifier -> STATIC .)
    VOID            reduce using rule 17 (modifier -> STATIC .)
    INT             reduce using rule 17 (modifier -> STATIC .)
    FLOAT           reduce using rule 17 (modifier -> STATIC .)
    BOOLEAN         reduce using rule 17 (modifier -> STATIC .)
    STRING          reduce using rule 17 (modifier -> STATIC .)


state 22

    (20) modifier -> empty .

    ID              reduce using rule 20 (modifier -> empty .)
    VOID            reduce using rule 20 (modifier -> empty .)
    INT             reduce using rule 20 (modifier -> empty .)
    FLOAT           reduce using rule 20 (modifier -> empty .)
    BOOLEAN         reduce using rule 20 (modifier -> empty .)
    STRING          reduce using rule 20 (modifier -> empty .)


state 23

    (22) type -> INT .

    ID              reduce using rule 22 (type -> INT .)


state 24

    (23) type -> FLOAT .

    ID              reduce using rule 23 (type -> FLOAT .)


state 25

    (24) type -> BOOLEAN .

    ID              reduce using rule 24 (type -> BOOLEAN .)


state 26

    (25) type -> STRING .

    ID              reduce using rule 25 (type -> STRING .)


state 27

    (6) class_decl -> CLASS ID EXTENDS ID . LCURLY class_body RCURLY

    LCURLY          shift and go to state 43


state 28

    (40) constructor_decl -> ID LPAREN . RPAREN block
    (41) constructor_decl -> ID LPAREN . formals RPAREN block
    (42) formals -> . formal_param
    (43) formals -> . formal_param COMMA formals
    (44) formal_param -> . type variable
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID

    RPAREN          shift and go to state 45
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 44

    formals                        shift and go to state 46
    formal_param                   shift and go to state 47
    type                           shift and go to state 48

state 29

    (5) class_decl -> CLASS ID LCURLY class_body RCURLY .

    CLASS           reduce using rule 5 (class_decl -> CLASS ID LCURLY class_body RCURLY .)
    $end            reduce using rule 5 (class_decl -> CLASS ID LCURLY class_body RCURLY .)


state 30

    (10) class_body -> class_body field_decl .

    RCURLY          reduce using rule 10 (class_body -> class_body field_decl .)
    ID              reduce using rule 10 (class_body -> class_body field_decl .)
    VOID            reduce using rule 10 (class_body -> class_body field_decl .)
    PUBLIC          reduce using rule 10 (class_body -> class_body field_decl .)
    PRIVATE         reduce using rule 10 (class_body -> class_body field_decl .)
    STATIC          reduce using rule 10 (class_body -> class_body field_decl .)
    INT             reduce using rule 10 (class_body -> class_body field_decl .)
    FLOAT           reduce using rule 10 (class_body -> class_body field_decl .)
    BOOLEAN         reduce using rule 10 (class_body -> class_body field_decl .)
    STRING          reduce using rule 10 (class_body -> class_body field_decl .)


state 31

    (11) class_body -> class_body constructor_decl .

    RCURLY          reduce using rule 11 (class_body -> class_body constructor_decl .)
    ID              reduce using rule 11 (class_body -> class_body constructor_decl .)
    VOID            reduce using rule 11 (class_body -> class_body constructor_decl .)
    PUBLIC          reduce using rule 11 (class_body -> class_body constructor_decl .)
    PRIVATE         reduce using rule 11 (class_body -> class_body constructor_decl .)
    STATIC          reduce using rule 11 (class_body -> class_body constructor_decl .)
    INT             reduce using rule 11 (class_body -> class_body constructor_decl .)
    FLOAT           reduce using rule 11 (class_body -> class_body constructor_decl .)
    BOOLEAN         reduce using rule 11 (class_body -> class_body constructor_decl .)
    STRING          reduce using rule 11 (class_body -> class_body constructor_decl .)


state 32

    (12) class_body -> class_body method_decl .

    RCURLY          reduce using rule 12 (class_body -> class_body method_decl .)
    ID              reduce using rule 12 (class_body -> class_body method_decl .)
    VOID            reduce using rule 12 (class_body -> class_body method_decl .)
    PUBLIC          reduce using rule 12 (class_body -> class_body method_decl .)
    PRIVATE         reduce using rule 12 (class_body -> class_body method_decl .)
    STATIC          reduce using rule 12 (class_body -> class_body method_decl .)
    INT             reduce using rule 12 (class_body -> class_body method_decl .)
    FLOAT           reduce using rule 12 (class_body -> class_body method_decl .)
    BOOLEAN         reduce using rule 12 (class_body -> class_body method_decl .)
    STRING          reduce using rule 12 (class_body -> class_body method_decl .)


state 33

    (14) field_decl -> modifier var_decl .

    RCURLY          reduce using rule 14 (field_decl -> modifier var_decl .)
    ID              reduce using rule 14 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 14 (field_decl -> modifier var_decl .)
    PUBLIC          reduce using rule 14 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 14 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 14 (field_decl -> modifier var_decl .)
    INT             reduce using rule 14 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 14 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 14 (field_decl -> modifier var_decl .)
    STRING          reduce using rule 14 (field_decl -> modifier var_decl .)


state 34

    (38) constructor_decl -> modifier ID . LPAREN RPAREN block
    (39) constructor_decl -> modifier ID . LPAREN formals RPAREN block
    (26) type -> ID .

    LPAREN          shift and go to state 49
    ID              reduce using rule 26 (type -> ID .)


state 35

    (30) method_decl -> modifier type . ID LPAREN RPAREN block
    (31) method_decl -> modifier type . ID LPAREN formals RPAREN block
    (21) var_decl -> type . variables SEMICOLON
    (27) variables -> . variable
    (28) variables -> . variables COMMA variable
    (29) variable -> . ID

    ID              shift and go to state 50

    variables                      shift and go to state 38
    variable                       shift and go to state 39

state 36

    (32) method_decl -> modifier VOID . ID LPAREN RPAREN block
    (33) method_decl -> modifier VOID . ID LPAREN formals RPAREN block

    ID              shift and go to state 51


state 37

    (34) method_decl -> type ID . LPAREN RPAREN block
    (35) method_decl -> type ID . LPAREN formals RPAREN block
    (29) variable -> ID .

    LPAREN          shift and go to state 52
    SEMICOLON       reduce using rule 29 (variable -> ID .)
    COMMA           reduce using rule 29 (variable -> ID .)


state 38

    (21) var_decl -> type variables . SEMICOLON
    (28) variables -> variables . COMMA variable

    SEMICOLON       shift and go to state 53
    COMMA           shift and go to state 54


state 39

    (27) variables -> variable .

    SEMICOLON       reduce using rule 27 (variables -> variable .)
    COMMA           reduce using rule 27 (variables -> variable .)


state 40

    (36) method_decl -> VOID ID . LPAREN RPAREN block
    (37) method_decl -> VOID ID . LPAREN formals RPAREN block

    LPAREN          shift and go to state 55


state 41

    (18) modifier -> PUBLIC STATIC .

    ID              reduce using rule 18 (modifier -> PUBLIC STATIC .)
    VOID            reduce using rule 18 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 18 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 18 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 18 (modifier -> PUBLIC STATIC .)
    STRING          reduce using rule 18 (modifier -> PUBLIC STATIC .)


state 42

    (19) modifier -> PRIVATE STATIC .

    ID              reduce using rule 19 (modifier -> PRIVATE STATIC .)
    VOID            reduce using rule 19 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 19 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 19 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 19 (modifier -> PRIVATE STATIC .)
    STRING          reduce using rule 19 (modifier -> PRIVATE STATIC .)


state 43

    (6) class_decl -> CLASS ID EXTENDS ID LCURLY . class_body RCURLY
    (7) class_body -> . field_decl
    (8) class_body -> . constructor_decl
    (9) class_body -> . method_decl
    (10) class_body -> . class_body field_decl
    (11) class_body -> . class_body constructor_decl
    (12) class_body -> . class_body method_decl
    (13) field_decl -> . var_decl
    (14) field_decl -> . modifier var_decl
    (38) constructor_decl -> . modifier ID LPAREN RPAREN block
    (39) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (40) constructor_decl -> . ID LPAREN RPAREN block
    (41) constructor_decl -> . ID LPAREN formals RPAREN block
    (30) method_decl -> . modifier type ID LPAREN RPAREN block
    (31) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (32) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (33) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (34) method_decl -> . type ID LPAREN RPAREN block
    (35) method_decl -> . type ID LPAREN formals RPAREN block
    (36) method_decl -> . VOID ID LPAREN RPAREN block
    (37) method_decl -> . VOID ID LPAREN formals RPAREN block
    (21) var_decl -> . type variables SEMICOLON
    (15) modifier -> . PUBLIC
    (16) modifier -> . PRIVATE
    (17) modifier -> . STATIC
    (18) modifier -> . PUBLIC STATIC
    (19) modifier -> . PRIVATE STATIC
    (20) modifier -> . empty
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (118) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 10
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 19
    PRIVATE         shift and go to state 20
    STATIC          shift and go to state 21
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26

  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! VOID            [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]

    class_body                     shift and go to state 56
    field_decl                     shift and go to state 12
    constructor_decl               shift and go to state 13
    method_decl                    shift and go to state 14
    var_decl                       shift and go to state 15
    modifier                       shift and go to state 16
    type                           shift and go to state 17
    empty                          shift and go to state 22

state 44

    (26) type -> ID .

    ID              reduce using rule 26 (type -> ID .)


state 45

    (40) constructor_decl -> ID LPAREN RPAREN . block
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (118) empty -> .

    LCURLY          shift and go to state 58
    RCURLY          reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    PUBLIC          reduce using rule 118 (empty -> .)
    PRIVATE         reduce using rule 118 (empty -> .)
    STATIC          reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    BOOLEAN         reduce using rule 118 (empty -> .)
    STRING          reduce using rule 118 (empty -> .)

    block                          shift and go to state 57
    empty                          shift and go to state 59

state 46

    (41) constructor_decl -> ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 60


state 47

    (42) formals -> formal_param .
    (43) formals -> formal_param . COMMA formals

    RPAREN          reduce using rule 42 (formals -> formal_param .)
    COMMA           shift and go to state 61


state 48

    (44) formal_param -> type . variable
    (29) variable -> . ID

    ID              shift and go to state 63

    variable                       shift and go to state 62

state 49

    (38) constructor_decl -> modifier ID LPAREN . RPAREN block
    (39) constructor_decl -> modifier ID LPAREN . formals RPAREN block
    (42) formals -> . formal_param
    (43) formals -> . formal_param COMMA formals
    (44) formal_param -> . type variable
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID

    RPAREN          shift and go to state 64
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 44

    formals                        shift and go to state 65
    formal_param                   shift and go to state 47
    type                           shift and go to state 48

state 50

    (30) method_decl -> modifier type ID . LPAREN RPAREN block
    (31) method_decl -> modifier type ID . LPAREN formals RPAREN block
    (29) variable -> ID .

    LPAREN          shift and go to state 66
    SEMICOLON       reduce using rule 29 (variable -> ID .)
    COMMA           reduce using rule 29 (variable -> ID .)


state 51

    (32) method_decl -> modifier VOID ID . LPAREN RPAREN block
    (33) method_decl -> modifier VOID ID . LPAREN formals RPAREN block

    LPAREN          shift and go to state 67


state 52

    (34) method_decl -> type ID LPAREN . RPAREN block
    (35) method_decl -> type ID LPAREN . formals RPAREN block
    (42) formals -> . formal_param
    (43) formals -> . formal_param COMMA formals
    (44) formal_param -> . type variable
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID

    RPAREN          shift and go to state 68
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 44

    type                           shift and go to state 48
    formals                        shift and go to state 69
    formal_param                   shift and go to state 47

state 53

    (21) var_decl -> type variables SEMICOLON .

    RCURLY          reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    ID              reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    VOID            reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    PUBLIC          reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    PRIVATE         reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    STATIC          reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    INT             reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    FLOAT           reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    BOOLEAN         reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    STRING          reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    IF              reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    WHILE           reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    FOR             reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    RETURN          reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    BREAK           reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    CONTINUE        reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    SEMICOLON       reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    LCURLY          reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    PLUSPLUS        reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    MINUSMINUS      reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    THIS            reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    SUPER           reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    LPAREN          reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    NEW             reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    INTEGER         reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    STRING_LITERAL  reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    NULL            reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    FALSE           reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    TRUE            reduce using rule 21 (var_decl -> type variables SEMICOLON .)
    ELSE            reduce using rule 21 (var_decl -> type variables SEMICOLON .)


state 54

    (28) variables -> variables COMMA . variable
    (29) variable -> . ID

    ID              shift and go to state 63

    variable                       shift and go to state 70

state 55

    (36) method_decl -> VOID ID LPAREN . RPAREN block
    (37) method_decl -> VOID ID LPAREN . formals RPAREN block
    (42) formals -> . formal_param
    (43) formals -> . formal_param COMMA formals
    (44) formal_param -> . type variable
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID

    RPAREN          shift and go to state 71
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 44

    formals                        shift and go to state 72
    formal_param                   shift and go to state 47
    type                           shift and go to state 48

state 56

    (6) class_decl -> CLASS ID EXTENDS ID LCURLY class_body . RCURLY
    (10) class_body -> class_body . field_decl
    (11) class_body -> class_body . constructor_decl
    (12) class_body -> class_body . method_decl
    (13) field_decl -> . var_decl
    (14) field_decl -> . modifier var_decl
    (38) constructor_decl -> . modifier ID LPAREN RPAREN block
    (39) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (40) constructor_decl -> . ID LPAREN RPAREN block
    (41) constructor_decl -> . ID LPAREN formals RPAREN block
    (30) method_decl -> . modifier type ID LPAREN RPAREN block
    (31) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (32) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (33) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (34) method_decl -> . type ID LPAREN RPAREN block
    (35) method_decl -> . type ID LPAREN formals RPAREN block
    (36) method_decl -> . VOID ID LPAREN RPAREN block
    (37) method_decl -> . VOID ID LPAREN formals RPAREN block
    (21) var_decl -> . type variables SEMICOLON
    (15) modifier -> . PUBLIC
    (16) modifier -> . PRIVATE
    (17) modifier -> . STATIC
    (18) modifier -> . PUBLIC STATIC
    (19) modifier -> . PRIVATE STATIC
    (20) modifier -> . empty
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (118) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    RCURLY          shift and go to state 73
    ID              shift and go to state 10
    VOID            shift and go to state 18
    PUBLIC          shift and go to state 19
    PRIVATE         shift and go to state 20
    STATIC          shift and go to state 21
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26

  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! VOID            [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]

    field_decl                     shift and go to state 30
    constructor_decl               shift and go to state 31
    method_decl                    shift and go to state 32
    var_decl                       shift and go to state 15
    modifier                       shift and go to state 16
    type                           shift and go to state 17
    empty                          shift and go to state 22

state 57

    (40) constructor_decl -> ID LPAREN RPAREN block .

    RCURLY          reduce using rule 40 (constructor_decl -> ID LPAREN RPAREN block .)
    ID              reduce using rule 40 (constructor_decl -> ID LPAREN RPAREN block .)
    VOID            reduce using rule 40 (constructor_decl -> ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 40 (constructor_decl -> ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 40 (constructor_decl -> ID LPAREN RPAREN block .)
    STATIC          reduce using rule 40 (constructor_decl -> ID LPAREN RPAREN block .)
    INT             reduce using rule 40 (constructor_decl -> ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 40 (constructor_decl -> ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 40 (constructor_decl -> ID LPAREN RPAREN block .)
    STRING          reduce using rule 40 (constructor_decl -> ID LPAREN RPAREN block .)


state 58

    (45) block -> LCURLY . stmtlist RCURLY
    (47) stmtlist -> . stmt
    (48) stmtlist -> . stmtlist stmt
    (49) stmt -> . IF LPAREN expression RPAREN stmt
    (50) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (51) stmt -> . WHILE LPAREN expression RPAREN stmt
    (52) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (60) stmt -> . RETURN expression SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . stmt_expression SEMICOLON
    (63) stmt -> . BREAK SEMICOLON
    (64) stmt -> . CONTINUE SEMICOLON
    (65) stmt -> . block
    (66) stmt -> . var_decl
    (67) stmt -> . SEMICOLON
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (21) var_decl -> . type variables SEMICOLON
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (118) empty -> .
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for PLUSPLUS resolved as shift
  ! shift/reduce conflict for MINUSMINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 76
    WHILE           shift and go to state 78
    FOR             shift and go to state 79
    RETURN          shift and go to state 82
    BREAK           shift and go to state 83
    CONTINUE        shift and go to state 84
    SEMICOLON       shift and go to state 81
    LCURLY          shift and go to state 58
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    RCURLY          reduce using rule 118 (empty -> .)
    INT             shift and go to state 23
    FLOAT           shift and go to state 94
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 95
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

  ! IF              [ reduce using rule 118 (empty -> .) ]
  ! WHILE           [ reduce using rule 118 (empty -> .) ]
  ! FOR             [ reduce using rule 118 (empty -> .) ]
  ! RETURN          [ reduce using rule 118 (empty -> .) ]
  ! BREAK           [ reduce using rule 118 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 118 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 118 (empty -> .) ]
  ! LCURLY          [ reduce using rule 118 (empty -> .) ]
  ! PLUSPLUS        [ reduce using rule 118 (empty -> .) ]
  ! MINUSMINUS      [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]
  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! THIS            [ reduce using rule 118 (empty -> .) ]
  ! SUPER           [ reduce using rule 118 (empty -> .) ]
  ! LPAREN          [ reduce using rule 118 (empty -> .) ]
  ! NEW             [ reduce using rule 118 (empty -> .) ]
  ! INTEGER         [ reduce using rule 118 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 118 (empty -> .) ]
  ! NULL            [ reduce using rule 118 (empty -> .) ]
  ! FALSE           [ reduce using rule 118 (empty -> .) ]
  ! TRUE            [ reduce using rule 118 (empty -> .) ]

    stmtlist                       shift and go to state 74
    stmt                           shift and go to state 75
    stmt_expression                shift and go to state 80
    block                          shift and go to state 85
    var_decl                       shift and go to state 86
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    empty                          shift and go to state 59
    type                           shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 59

    (46) block -> empty .

    RCURLY          reduce using rule 46 (block -> empty .)
    ID              reduce using rule 46 (block -> empty .)
    VOID            reduce using rule 46 (block -> empty .)
    PUBLIC          reduce using rule 46 (block -> empty .)
    PRIVATE         reduce using rule 46 (block -> empty .)
    STATIC          reduce using rule 46 (block -> empty .)
    INT             reduce using rule 46 (block -> empty .)
    FLOAT           reduce using rule 46 (block -> empty .)
    BOOLEAN         reduce using rule 46 (block -> empty .)
    STRING          reduce using rule 46 (block -> empty .)
    IF              reduce using rule 46 (block -> empty .)
    WHILE           reduce using rule 46 (block -> empty .)
    FOR             reduce using rule 46 (block -> empty .)
    RETURN          reduce using rule 46 (block -> empty .)
    BREAK           reduce using rule 46 (block -> empty .)
    CONTINUE        reduce using rule 46 (block -> empty .)
    SEMICOLON       reduce using rule 46 (block -> empty .)
    LCURLY          reduce using rule 46 (block -> empty .)
    PLUSPLUS        reduce using rule 46 (block -> empty .)
    MINUSMINUS      reduce using rule 46 (block -> empty .)
    THIS            reduce using rule 46 (block -> empty .)
    SUPER           reduce using rule 46 (block -> empty .)
    LPAREN          reduce using rule 46 (block -> empty .)
    NEW             reduce using rule 46 (block -> empty .)
    INTEGER         reduce using rule 46 (block -> empty .)
    STRING_LITERAL  reduce using rule 46 (block -> empty .)
    NULL            reduce using rule 46 (block -> empty .)
    FALSE           reduce using rule 46 (block -> empty .)
    TRUE            reduce using rule 46 (block -> empty .)
    ELSE            reduce using rule 46 (block -> empty .)


state 60

    (41) constructor_decl -> ID LPAREN formals RPAREN . block
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (118) empty -> .

    LCURLY          shift and go to state 58
    RCURLY          reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    PUBLIC          reduce using rule 118 (empty -> .)
    PRIVATE         reduce using rule 118 (empty -> .)
    STATIC          reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    BOOLEAN         reduce using rule 118 (empty -> .)
    STRING          reduce using rule 118 (empty -> .)

    block                          shift and go to state 106
    empty                          shift and go to state 59

state 61

    (43) formals -> formal_param COMMA . formals
    (42) formals -> . formal_param
    (43) formals -> . formal_param COMMA formals
    (44) formal_param -> . type variable
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID

    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 44

    formal_param                   shift and go to state 47
    formals                        shift and go to state 107
    type                           shift and go to state 48

state 62

    (44) formal_param -> type variable .

    COMMA           reduce using rule 44 (formal_param -> type variable .)
    RPAREN          reduce using rule 44 (formal_param -> type variable .)


state 63

    (29) variable -> ID .

    COMMA           reduce using rule 29 (variable -> ID .)
    RPAREN          reduce using rule 29 (variable -> ID .)
    SEMICOLON       reduce using rule 29 (variable -> ID .)


state 64

    (38) constructor_decl -> modifier ID LPAREN RPAREN . block
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (118) empty -> .

    LCURLY          shift and go to state 58
    RCURLY          reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    PUBLIC          reduce using rule 118 (empty -> .)
    PRIVATE         reduce using rule 118 (empty -> .)
    STATIC          reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    BOOLEAN         reduce using rule 118 (empty -> .)
    STRING          reduce using rule 118 (empty -> .)

    block                          shift and go to state 108
    empty                          shift and go to state 59

state 65

    (39) constructor_decl -> modifier ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 109


state 66

    (30) method_decl -> modifier type ID LPAREN . RPAREN block
    (31) method_decl -> modifier type ID LPAREN . formals RPAREN block
    (42) formals -> . formal_param
    (43) formals -> . formal_param COMMA formals
    (44) formal_param -> . type variable
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID

    RPAREN          shift and go to state 110
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 44

    type                           shift and go to state 48
    formals                        shift and go to state 111
    formal_param                   shift and go to state 47

state 67

    (32) method_decl -> modifier VOID ID LPAREN . RPAREN block
    (33) method_decl -> modifier VOID ID LPAREN . formals RPAREN block
    (42) formals -> . formal_param
    (43) formals -> . formal_param COMMA formals
    (44) formal_param -> . type variable
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID

    RPAREN          shift and go to state 112
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 44

    formals                        shift and go to state 113
    formal_param                   shift and go to state 47
    type                           shift and go to state 48

state 68

    (34) method_decl -> type ID LPAREN RPAREN . block
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (118) empty -> .

    LCURLY          shift and go to state 58
    RCURLY          reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    PUBLIC          reduce using rule 118 (empty -> .)
    PRIVATE         reduce using rule 118 (empty -> .)
    STATIC          reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    BOOLEAN         reduce using rule 118 (empty -> .)
    STRING          reduce using rule 118 (empty -> .)

    block                          shift and go to state 114
    empty                          shift and go to state 59

state 69

    (35) method_decl -> type ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 115


state 70

    (28) variables -> variables COMMA variable .

    SEMICOLON       reduce using rule 28 (variables -> variables COMMA variable .)
    COMMA           reduce using rule 28 (variables -> variables COMMA variable .)


state 71

    (36) method_decl -> VOID ID LPAREN RPAREN . block
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (118) empty -> .

    LCURLY          shift and go to state 58
    RCURLY          reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    PUBLIC          reduce using rule 118 (empty -> .)
    PRIVATE         reduce using rule 118 (empty -> .)
    STATIC          reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    BOOLEAN         reduce using rule 118 (empty -> .)
    STRING          reduce using rule 118 (empty -> .)

    block                          shift and go to state 116
    empty                          shift and go to state 59

state 72

    (37) method_decl -> VOID ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 117


state 73

    (6) class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY .

    CLASS           reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY .)
    $end            reduce using rule 6 (class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY .)


state 74

    (45) block -> LCURLY stmtlist . RCURLY
    (48) stmtlist -> stmtlist . stmt
    (49) stmt -> . IF LPAREN expression RPAREN stmt
    (50) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (51) stmt -> . WHILE LPAREN expression RPAREN stmt
    (52) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (60) stmt -> . RETURN expression SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . stmt_expression SEMICOLON
    (63) stmt -> . BREAK SEMICOLON
    (64) stmt -> . CONTINUE SEMICOLON
    (65) stmt -> . block
    (66) stmt -> . var_decl
    (67) stmt -> . SEMICOLON
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (21) var_decl -> . type variables SEMICOLON
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (118) empty -> .
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

  ! shift/reduce conflict for RCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for PLUSPLUS resolved as shift
  ! shift/reduce conflict for MINUSMINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    RCURLY          shift and go to state 118
    IF              shift and go to state 76
    WHILE           shift and go to state 78
    FOR             shift and go to state 79
    RETURN          shift and go to state 82
    BREAK           shift and go to state 83
    CONTINUE        shift and go to state 84
    SEMICOLON       shift and go to state 81
    LCURLY          shift and go to state 58
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    INT             shift and go to state 23
    FLOAT           shift and go to state 94
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 95
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

  ! RCURLY          [ reduce using rule 118 (empty -> .) ]
  ! IF              [ reduce using rule 118 (empty -> .) ]
  ! WHILE           [ reduce using rule 118 (empty -> .) ]
  ! FOR             [ reduce using rule 118 (empty -> .) ]
  ! RETURN          [ reduce using rule 118 (empty -> .) ]
  ! BREAK           [ reduce using rule 118 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 118 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 118 (empty -> .) ]
  ! LCURLY          [ reduce using rule 118 (empty -> .) ]
  ! PLUSPLUS        [ reduce using rule 118 (empty -> .) ]
  ! MINUSMINUS      [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]
  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! THIS            [ reduce using rule 118 (empty -> .) ]
  ! SUPER           [ reduce using rule 118 (empty -> .) ]
  ! LPAREN          [ reduce using rule 118 (empty -> .) ]
  ! NEW             [ reduce using rule 118 (empty -> .) ]
  ! INTEGER         [ reduce using rule 118 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 118 (empty -> .) ]
  ! NULL            [ reduce using rule 118 (empty -> .) ]
  ! FALSE           [ reduce using rule 118 (empty -> .) ]
  ! TRUE            [ reduce using rule 118 (empty -> .) ]

    stmt                           shift and go to state 119
    stmt_expression                shift and go to state 80
    block                          shift and go to state 85
    var_decl                       shift and go to state 86
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    empty                          shift and go to state 59
    type                           shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 75

    (47) stmtlist -> stmt .

    RCURLY          reduce using rule 47 (stmtlist -> stmt .)
    IF              reduce using rule 47 (stmtlist -> stmt .)
    WHILE           reduce using rule 47 (stmtlist -> stmt .)
    FOR             reduce using rule 47 (stmtlist -> stmt .)
    RETURN          reduce using rule 47 (stmtlist -> stmt .)
    BREAK           reduce using rule 47 (stmtlist -> stmt .)
    CONTINUE        reduce using rule 47 (stmtlist -> stmt .)
    SEMICOLON       reduce using rule 47 (stmtlist -> stmt .)
    LCURLY          reduce using rule 47 (stmtlist -> stmt .)
    PLUSPLUS        reduce using rule 47 (stmtlist -> stmt .)
    MINUSMINUS      reduce using rule 47 (stmtlist -> stmt .)
    INT             reduce using rule 47 (stmtlist -> stmt .)
    FLOAT           reduce using rule 47 (stmtlist -> stmt .)
    BOOLEAN         reduce using rule 47 (stmtlist -> stmt .)
    STRING          reduce using rule 47 (stmtlist -> stmt .)
    ID              reduce using rule 47 (stmtlist -> stmt .)
    THIS            reduce using rule 47 (stmtlist -> stmt .)
    SUPER           reduce using rule 47 (stmtlist -> stmt .)
    LPAREN          reduce using rule 47 (stmtlist -> stmt .)
    NEW             reduce using rule 47 (stmtlist -> stmt .)
    INTEGER         reduce using rule 47 (stmtlist -> stmt .)
    STRING_LITERAL  reduce using rule 47 (stmtlist -> stmt .)
    NULL            reduce using rule 47 (stmtlist -> stmt .)
    FALSE           reduce using rule 47 (stmtlist -> stmt .)
    TRUE            reduce using rule 47 (stmtlist -> stmt .)


state 76

    (49) stmt -> IF . LPAREN expression RPAREN stmt
    (50) stmt -> IF . LPAREN expression RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 120


state 77

    (77) primary -> LPAREN . expression RPAREN
    (89) expression -> . primary
    (90) expression -> . assign
    (91) expression -> . expression arith_op expression
    (92) expression -> . expression bool_op expression
    (93) expression -> . unary_op expression
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (113) unary_op -> . PLUS
    (114) unary_op -> . MINUS
    (115) unary_op -> . NOT
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    NOT             shift and go to state 130
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105
    ID              shift and go to state 125

    expression                     shift and go to state 121
    primary                        shift and go to state 122
    assign                         shift and go to state 123
    unary_op                       shift and go to state 124
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126
    lhs                            shift and go to state 127
    field_access                   shift and go to state 93

state 78

    (51) stmt -> WHILE . LPAREN expression RPAREN stmt

    LPAREN          shift and go to state 132


state 79

    (52) stmt -> FOR . LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> FOR . LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> FOR . LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> FOR . LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> FOR . LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> FOR . LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> FOR . LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> FOR . LPAREN SEMICOLON SEMICOLON RPAREN stmt

    LPAREN          shift and go to state 133


state 80

    (62) stmt -> stmt_expression . SEMICOLON

    SEMICOLON       shift and go to state 134


state 81

    (67) stmt -> SEMICOLON .

    RCURLY          reduce using rule 67 (stmt -> SEMICOLON .)
    IF              reduce using rule 67 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 67 (stmt -> SEMICOLON .)
    FOR             reduce using rule 67 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 67 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 67 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 67 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 67 (stmt -> SEMICOLON .)
    LCURLY          reduce using rule 67 (stmt -> SEMICOLON .)
    PLUSPLUS        reduce using rule 67 (stmt -> SEMICOLON .)
    MINUSMINUS      reduce using rule 67 (stmt -> SEMICOLON .)
    INT             reduce using rule 67 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 67 (stmt -> SEMICOLON .)
    BOOLEAN         reduce using rule 67 (stmt -> SEMICOLON .)
    STRING          reduce using rule 67 (stmt -> SEMICOLON .)
    ID              reduce using rule 67 (stmt -> SEMICOLON .)
    THIS            reduce using rule 67 (stmt -> SEMICOLON .)
    SUPER           reduce using rule 67 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 67 (stmt -> SEMICOLON .)
    NEW             reduce using rule 67 (stmt -> SEMICOLON .)
    INTEGER         reduce using rule 67 (stmt -> SEMICOLON .)
    STRING_LITERAL  reduce using rule 67 (stmt -> SEMICOLON .)
    NULL            reduce using rule 67 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 67 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 67 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 67 (stmt -> SEMICOLON .)


state 82

    (60) stmt -> RETURN . expression SEMICOLON
    (61) stmt -> RETURN . SEMICOLON
    (89) expression -> . primary
    (90) expression -> . assign
    (91) expression -> . expression arith_op expression
    (92) expression -> . expression bool_op expression
    (93) expression -> . unary_op expression
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (113) unary_op -> . PLUS
    (114) unary_op -> . MINUS
    (115) unary_op -> . NOT
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID

    SEMICOLON       shift and go to state 136
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    NOT             shift and go to state 130
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105
    ID              shift and go to state 125

    expression                     shift and go to state 135
    primary                        shift and go to state 122
    assign                         shift and go to state 123
    unary_op                       shift and go to state 124
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126
    lhs                            shift and go to state 127
    field_access                   shift and go to state 93

state 83

    (63) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 137


state 84

    (64) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 138


state 85

    (65) stmt -> block .

    RCURLY          reduce using rule 65 (stmt -> block .)
    IF              reduce using rule 65 (stmt -> block .)
    WHILE           reduce using rule 65 (stmt -> block .)
    FOR             reduce using rule 65 (stmt -> block .)
    RETURN          reduce using rule 65 (stmt -> block .)
    BREAK           reduce using rule 65 (stmt -> block .)
    CONTINUE        reduce using rule 65 (stmt -> block .)
    SEMICOLON       reduce using rule 65 (stmt -> block .)
    LCURLY          reduce using rule 65 (stmt -> block .)
    PLUSPLUS        reduce using rule 65 (stmt -> block .)
    MINUSMINUS      reduce using rule 65 (stmt -> block .)
    INT             reduce using rule 65 (stmt -> block .)
    FLOAT           reduce using rule 65 (stmt -> block .)
    BOOLEAN         reduce using rule 65 (stmt -> block .)
    STRING          reduce using rule 65 (stmt -> block .)
    ID              reduce using rule 65 (stmt -> block .)
    THIS            reduce using rule 65 (stmt -> block .)
    SUPER           reduce using rule 65 (stmt -> block .)
    LPAREN          reduce using rule 65 (stmt -> block .)
    NEW             reduce using rule 65 (stmt -> block .)
    INTEGER         reduce using rule 65 (stmt -> block .)
    STRING_LITERAL  reduce using rule 65 (stmt -> block .)
    NULL            reduce using rule 65 (stmt -> block .)
    FALSE           reduce using rule 65 (stmt -> block .)
    TRUE            reduce using rule 65 (stmt -> block .)
    ELSE            reduce using rule 65 (stmt -> block .)


state 86

    (66) stmt -> var_decl .

    RCURLY          reduce using rule 66 (stmt -> var_decl .)
    IF              reduce using rule 66 (stmt -> var_decl .)
    WHILE           reduce using rule 66 (stmt -> var_decl .)
    FOR             reduce using rule 66 (stmt -> var_decl .)
    RETURN          reduce using rule 66 (stmt -> var_decl .)
    BREAK           reduce using rule 66 (stmt -> var_decl .)
    CONTINUE        reduce using rule 66 (stmt -> var_decl .)
    SEMICOLON       reduce using rule 66 (stmt -> var_decl .)
    LCURLY          reduce using rule 66 (stmt -> var_decl .)
    PLUSPLUS        reduce using rule 66 (stmt -> var_decl .)
    MINUSMINUS      reduce using rule 66 (stmt -> var_decl .)
    INT             reduce using rule 66 (stmt -> var_decl .)
    FLOAT           reduce using rule 66 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 66 (stmt -> var_decl .)
    STRING          reduce using rule 66 (stmt -> var_decl .)
    ID              reduce using rule 66 (stmt -> var_decl .)
    THIS            reduce using rule 66 (stmt -> var_decl .)
    SUPER           reduce using rule 66 (stmt -> var_decl .)
    LPAREN          reduce using rule 66 (stmt -> var_decl .)
    NEW             reduce using rule 66 (stmt -> var_decl .)
    INTEGER         reduce using rule 66 (stmt -> var_decl .)
    STRING_LITERAL  reduce using rule 66 (stmt -> var_decl .)
    NULL            reduce using rule 66 (stmt -> var_decl .)
    FALSE           reduce using rule 66 (stmt -> var_decl .)
    TRUE            reduce using rule 66 (stmt -> var_decl .)
    ELSE            reduce using rule 66 (stmt -> var_decl .)


state 87

    (116) stmt_expression -> assign .

    SEMICOLON       reduce using rule 116 (stmt_expression -> assign .)
    RPAREN          reduce using rule 116 (stmt_expression -> assign .)


state 88

    (117) stmt_expression -> method_invocation .
    (80) primary -> method_invocation .

    SEMICOLON       reduce using rule 117 (stmt_expression -> method_invocation .)
    RPAREN          reduce using rule 117 (stmt_expression -> method_invocation .)
    DOT             reduce using rule 80 (primary -> method_invocation .)


state 89

    (21) var_decl -> type . variables SEMICOLON
    (27) variables -> . variable
    (28) variables -> . variables COMMA variable
    (29) variable -> . ID

    ID              shift and go to state 63

    variables                      shift and go to state 38
    variable                       shift and go to state 39

state 90

    (96) assign -> lhs . SETEQUAL expression
    (97) assign -> lhs . PLUSPLUS
    (98) assign -> lhs . MINUSMINUS
    (81) primary -> lhs .

    SETEQUAL        shift and go to state 139
    PLUSPLUS        shift and go to state 140
    MINUSMINUS      shift and go to state 141
    DOT             reduce using rule 81 (primary -> lhs .)


state 91

    (99) assign -> PLUSPLUS . lhs
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN

    ID              shift and go to state 125
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

    lhs                            shift and go to state 142
    field_access                   shift and go to state 143
    primary                        shift and go to state 96
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126

state 92

    (100) assign -> MINUSMINUS . lhs
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN

    ID              shift and go to state 125
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

    lhs                            shift and go to state 144
    field_access                   shift and go to state 143
    primary                        shift and go to state 96
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126

state 93

    (87) method_invocation -> field_access . LPAREN arguments RPAREN
    (88) method_invocation -> field_access . LPAREN RPAREN
    (84) lhs -> field_access .

    LPAREN          shift and go to state 145
    SETEQUAL        reduce using rule 84 (lhs -> field_access .)
    PLUSPLUS        reduce using rule 84 (lhs -> field_access .)
    MINUSMINUS      reduce using rule 84 (lhs -> field_access .)
    DOT             reduce using rule 84 (lhs -> field_access .)
    RPAREN          reduce using rule 84 (lhs -> field_access .)
    PLUS            reduce using rule 84 (lhs -> field_access .)
    MINUS           reduce using rule 84 (lhs -> field_access .)
    TIMES           reduce using rule 84 (lhs -> field_access .)
    DIVIDE          reduce using rule 84 (lhs -> field_access .)
    GREATER         reduce using rule 84 (lhs -> field_access .)
    LESS            reduce using rule 84 (lhs -> field_access .)
    GREATEREQ       reduce using rule 84 (lhs -> field_access .)
    LESSEQ          reduce using rule 84 (lhs -> field_access .)
    EQUAL           reduce using rule 84 (lhs -> field_access .)
    NOTEQUAL        reduce using rule 84 (lhs -> field_access .)
    AND             reduce using rule 84 (lhs -> field_access .)
    OR              reduce using rule 84 (lhs -> field_access .)
    SEMICOLON       reduce using rule 84 (lhs -> field_access .)
    COMMA           reduce using rule 84 (lhs -> field_access .)


state 94

    (23) type -> FLOAT .
    (69) literal -> FLOAT .

    ID              reduce using rule 23 (type -> FLOAT .)
    DOT             reduce using rule 69 (literal -> FLOAT .)


state 95

    (26) type -> ID .
    (86) field_access -> ID .

    ID              reduce using rule 26 (type -> ID .)
    LPAREN          reduce using rule 86 (field_access -> ID .)
    SETEQUAL        reduce using rule 86 (field_access -> ID .)
    PLUSPLUS        reduce using rule 86 (field_access -> ID .)
    MINUSMINUS      reduce using rule 86 (field_access -> ID .)
    DOT             reduce using rule 86 (field_access -> ID .)


state 96

    (85) field_access -> primary . DOT ID

    DOT             shift and go to state 146


state 97

    (74) primary -> literal .

    DOT             reduce using rule 74 (primary -> literal .)
    RPAREN          reduce using rule 74 (primary -> literal .)
    PLUS            reduce using rule 74 (primary -> literal .)
    MINUS           reduce using rule 74 (primary -> literal .)
    TIMES           reduce using rule 74 (primary -> literal .)
    DIVIDE          reduce using rule 74 (primary -> literal .)
    GREATER         reduce using rule 74 (primary -> literal .)
    LESS            reduce using rule 74 (primary -> literal .)
    GREATEREQ       reduce using rule 74 (primary -> literal .)
    LESSEQ          reduce using rule 74 (primary -> literal .)
    EQUAL           reduce using rule 74 (primary -> literal .)
    NOTEQUAL        reduce using rule 74 (primary -> literal .)
    AND             reduce using rule 74 (primary -> literal .)
    OR              reduce using rule 74 (primary -> literal .)
    SEMICOLON       reduce using rule 74 (primary -> literal .)
    COMMA           reduce using rule 74 (primary -> literal .)


state 98

    (75) primary -> THIS .

    DOT             reduce using rule 75 (primary -> THIS .)
    RPAREN          reduce using rule 75 (primary -> THIS .)
    PLUS            reduce using rule 75 (primary -> THIS .)
    MINUS           reduce using rule 75 (primary -> THIS .)
    TIMES           reduce using rule 75 (primary -> THIS .)
    DIVIDE          reduce using rule 75 (primary -> THIS .)
    GREATER         reduce using rule 75 (primary -> THIS .)
    LESS            reduce using rule 75 (primary -> THIS .)
    GREATEREQ       reduce using rule 75 (primary -> THIS .)
    LESSEQ          reduce using rule 75 (primary -> THIS .)
    EQUAL           reduce using rule 75 (primary -> THIS .)
    NOTEQUAL        reduce using rule 75 (primary -> THIS .)
    AND             reduce using rule 75 (primary -> THIS .)
    OR              reduce using rule 75 (primary -> THIS .)
    SEMICOLON       reduce using rule 75 (primary -> THIS .)
    COMMA           reduce using rule 75 (primary -> THIS .)


state 99

    (76) primary -> SUPER .

    DOT             reduce using rule 76 (primary -> SUPER .)
    RPAREN          reduce using rule 76 (primary -> SUPER .)
    PLUS            reduce using rule 76 (primary -> SUPER .)
    MINUS           reduce using rule 76 (primary -> SUPER .)
    TIMES           reduce using rule 76 (primary -> SUPER .)
    DIVIDE          reduce using rule 76 (primary -> SUPER .)
    GREATER         reduce using rule 76 (primary -> SUPER .)
    LESS            reduce using rule 76 (primary -> SUPER .)
    GREATEREQ       reduce using rule 76 (primary -> SUPER .)
    LESSEQ          reduce using rule 76 (primary -> SUPER .)
    EQUAL           reduce using rule 76 (primary -> SUPER .)
    NOTEQUAL        reduce using rule 76 (primary -> SUPER .)
    AND             reduce using rule 76 (primary -> SUPER .)
    OR              reduce using rule 76 (primary -> SUPER .)
    SEMICOLON       reduce using rule 76 (primary -> SUPER .)
    COMMA           reduce using rule 76 (primary -> SUPER .)


state 100

    (78) primary -> NEW . ID LPAREN RPAREN
    (79) primary -> NEW . ID LPAREN arguments RPAREN

    ID              shift and go to state 147


state 101

    (68) literal -> INTEGER .

    DOT             reduce using rule 68 (literal -> INTEGER .)
    RPAREN          reduce using rule 68 (literal -> INTEGER .)
    PLUS            reduce using rule 68 (literal -> INTEGER .)
    MINUS           reduce using rule 68 (literal -> INTEGER .)
    TIMES           reduce using rule 68 (literal -> INTEGER .)
    DIVIDE          reduce using rule 68 (literal -> INTEGER .)
    GREATER         reduce using rule 68 (literal -> INTEGER .)
    LESS            reduce using rule 68 (literal -> INTEGER .)
    GREATEREQ       reduce using rule 68 (literal -> INTEGER .)
    LESSEQ          reduce using rule 68 (literal -> INTEGER .)
    EQUAL           reduce using rule 68 (literal -> INTEGER .)
    NOTEQUAL        reduce using rule 68 (literal -> INTEGER .)
    AND             reduce using rule 68 (literal -> INTEGER .)
    OR              reduce using rule 68 (literal -> INTEGER .)
    SEMICOLON       reduce using rule 68 (literal -> INTEGER .)
    COMMA           reduce using rule 68 (literal -> INTEGER .)


state 102

    (70) literal -> STRING_LITERAL .

    DOT             reduce using rule 70 (literal -> STRING_LITERAL .)
    RPAREN          reduce using rule 70 (literal -> STRING_LITERAL .)
    PLUS            reduce using rule 70 (literal -> STRING_LITERAL .)
    MINUS           reduce using rule 70 (literal -> STRING_LITERAL .)
    TIMES           reduce using rule 70 (literal -> STRING_LITERAL .)
    DIVIDE          reduce using rule 70 (literal -> STRING_LITERAL .)
    GREATER         reduce using rule 70 (literal -> STRING_LITERAL .)
    LESS            reduce using rule 70 (literal -> STRING_LITERAL .)
    GREATEREQ       reduce using rule 70 (literal -> STRING_LITERAL .)
    LESSEQ          reduce using rule 70 (literal -> STRING_LITERAL .)
    EQUAL           reduce using rule 70 (literal -> STRING_LITERAL .)
    NOTEQUAL        reduce using rule 70 (literal -> STRING_LITERAL .)
    AND             reduce using rule 70 (literal -> STRING_LITERAL .)
    OR              reduce using rule 70 (literal -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 70 (literal -> STRING_LITERAL .)
    COMMA           reduce using rule 70 (literal -> STRING_LITERAL .)


state 103

    (71) literal -> NULL .

    DOT             reduce using rule 71 (literal -> NULL .)
    RPAREN          reduce using rule 71 (literal -> NULL .)
    PLUS            reduce using rule 71 (literal -> NULL .)
    MINUS           reduce using rule 71 (literal -> NULL .)
    TIMES           reduce using rule 71 (literal -> NULL .)
    DIVIDE          reduce using rule 71 (literal -> NULL .)
    GREATER         reduce using rule 71 (literal -> NULL .)
    LESS            reduce using rule 71 (literal -> NULL .)
    GREATEREQ       reduce using rule 71 (literal -> NULL .)
    LESSEQ          reduce using rule 71 (literal -> NULL .)
    EQUAL           reduce using rule 71 (literal -> NULL .)
    NOTEQUAL        reduce using rule 71 (literal -> NULL .)
    AND             reduce using rule 71 (literal -> NULL .)
    OR              reduce using rule 71 (literal -> NULL .)
    SEMICOLON       reduce using rule 71 (literal -> NULL .)
    COMMA           reduce using rule 71 (literal -> NULL .)


state 104

    (72) literal -> FALSE .

    DOT             reduce using rule 72 (literal -> FALSE .)
    RPAREN          reduce using rule 72 (literal -> FALSE .)
    PLUS            reduce using rule 72 (literal -> FALSE .)
    MINUS           reduce using rule 72 (literal -> FALSE .)
    TIMES           reduce using rule 72 (literal -> FALSE .)
    DIVIDE          reduce using rule 72 (literal -> FALSE .)
    GREATER         reduce using rule 72 (literal -> FALSE .)
    LESS            reduce using rule 72 (literal -> FALSE .)
    GREATEREQ       reduce using rule 72 (literal -> FALSE .)
    LESSEQ          reduce using rule 72 (literal -> FALSE .)
    EQUAL           reduce using rule 72 (literal -> FALSE .)
    NOTEQUAL        reduce using rule 72 (literal -> FALSE .)
    AND             reduce using rule 72 (literal -> FALSE .)
    OR              reduce using rule 72 (literal -> FALSE .)
    SEMICOLON       reduce using rule 72 (literal -> FALSE .)
    COMMA           reduce using rule 72 (literal -> FALSE .)


state 105

    (73) literal -> TRUE .

    DOT             reduce using rule 73 (literal -> TRUE .)
    RPAREN          reduce using rule 73 (literal -> TRUE .)
    PLUS            reduce using rule 73 (literal -> TRUE .)
    MINUS           reduce using rule 73 (literal -> TRUE .)
    TIMES           reduce using rule 73 (literal -> TRUE .)
    DIVIDE          reduce using rule 73 (literal -> TRUE .)
    GREATER         reduce using rule 73 (literal -> TRUE .)
    LESS            reduce using rule 73 (literal -> TRUE .)
    GREATEREQ       reduce using rule 73 (literal -> TRUE .)
    LESSEQ          reduce using rule 73 (literal -> TRUE .)
    EQUAL           reduce using rule 73 (literal -> TRUE .)
    NOTEQUAL        reduce using rule 73 (literal -> TRUE .)
    AND             reduce using rule 73 (literal -> TRUE .)
    OR              reduce using rule 73 (literal -> TRUE .)
    SEMICOLON       reduce using rule 73 (literal -> TRUE .)
    COMMA           reduce using rule 73 (literal -> TRUE .)


state 106

    (41) constructor_decl -> ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 41 (constructor_decl -> ID LPAREN formals RPAREN block .)
    ID              reduce using rule 41 (constructor_decl -> ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 41 (constructor_decl -> ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 41 (constructor_decl -> ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 41 (constructor_decl -> ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 41 (constructor_decl -> ID LPAREN formals RPAREN block .)
    INT             reduce using rule 41 (constructor_decl -> ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 41 (constructor_decl -> ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 41 (constructor_decl -> ID LPAREN formals RPAREN block .)
    STRING          reduce using rule 41 (constructor_decl -> ID LPAREN formals RPAREN block .)


state 107

    (43) formals -> formal_param COMMA formals .

    RPAREN          reduce using rule 43 (formals -> formal_param COMMA formals .)


state 108

    (38) constructor_decl -> modifier ID LPAREN RPAREN block .

    RCURLY          reduce using rule 38 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    ID              reduce using rule 38 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    VOID            reduce using rule 38 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 38 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 38 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    STATIC          reduce using rule 38 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    INT             reduce using rule 38 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 38 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 38 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    STRING          reduce using rule 38 (constructor_decl -> modifier ID LPAREN RPAREN block .)


state 109

    (39) constructor_decl -> modifier ID LPAREN formals RPAREN . block
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (118) empty -> .

    LCURLY          shift and go to state 58
    RCURLY          reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    PUBLIC          reduce using rule 118 (empty -> .)
    PRIVATE         reduce using rule 118 (empty -> .)
    STATIC          reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    BOOLEAN         reduce using rule 118 (empty -> .)
    STRING          reduce using rule 118 (empty -> .)

    block                          shift and go to state 148
    empty                          shift and go to state 59

state 110

    (30) method_decl -> modifier type ID LPAREN RPAREN . block
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (118) empty -> .

    LCURLY          shift and go to state 58
    RCURLY          reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    PUBLIC          reduce using rule 118 (empty -> .)
    PRIVATE         reduce using rule 118 (empty -> .)
    STATIC          reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    BOOLEAN         reduce using rule 118 (empty -> .)
    STRING          reduce using rule 118 (empty -> .)

    block                          shift and go to state 149
    empty                          shift and go to state 59

state 111

    (31) method_decl -> modifier type ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 150


state 112

    (32) method_decl -> modifier VOID ID LPAREN RPAREN . block
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (118) empty -> .

    LCURLY          shift and go to state 58
    RCURLY          reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    PUBLIC          reduce using rule 118 (empty -> .)
    PRIVATE         reduce using rule 118 (empty -> .)
    STATIC          reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    BOOLEAN         reduce using rule 118 (empty -> .)
    STRING          reduce using rule 118 (empty -> .)

    block                          shift and go to state 151
    empty                          shift and go to state 59

state 113

    (33) method_decl -> modifier VOID ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 152


state 114

    (34) method_decl -> type ID LPAREN RPAREN block .

    RCURLY          reduce using rule 34 (method_decl -> type ID LPAREN RPAREN block .)
    ID              reduce using rule 34 (method_decl -> type ID LPAREN RPAREN block .)
    VOID            reduce using rule 34 (method_decl -> type ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 34 (method_decl -> type ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 34 (method_decl -> type ID LPAREN RPAREN block .)
    STATIC          reduce using rule 34 (method_decl -> type ID LPAREN RPAREN block .)
    INT             reduce using rule 34 (method_decl -> type ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 34 (method_decl -> type ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 34 (method_decl -> type ID LPAREN RPAREN block .)
    STRING          reduce using rule 34 (method_decl -> type ID LPAREN RPAREN block .)


state 115

    (35) method_decl -> type ID LPAREN formals RPAREN . block
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (118) empty -> .

    LCURLY          shift and go to state 58
    RCURLY          reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    PUBLIC          reduce using rule 118 (empty -> .)
    PRIVATE         reduce using rule 118 (empty -> .)
    STATIC          reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    BOOLEAN         reduce using rule 118 (empty -> .)
    STRING          reduce using rule 118 (empty -> .)

    block                          shift and go to state 153
    empty                          shift and go to state 59

state 116

    (36) method_decl -> VOID ID LPAREN RPAREN block .

    RCURLY          reduce using rule 36 (method_decl -> VOID ID LPAREN RPAREN block .)
    ID              reduce using rule 36 (method_decl -> VOID ID LPAREN RPAREN block .)
    VOID            reduce using rule 36 (method_decl -> VOID ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 36 (method_decl -> VOID ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 36 (method_decl -> VOID ID LPAREN RPAREN block .)
    STATIC          reduce using rule 36 (method_decl -> VOID ID LPAREN RPAREN block .)
    INT             reduce using rule 36 (method_decl -> VOID ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 36 (method_decl -> VOID ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 36 (method_decl -> VOID ID LPAREN RPAREN block .)
    STRING          reduce using rule 36 (method_decl -> VOID ID LPAREN RPAREN block .)


state 117

    (37) method_decl -> VOID ID LPAREN formals RPAREN . block
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (118) empty -> .

    LCURLY          shift and go to state 58
    RCURLY          reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    PUBLIC          reduce using rule 118 (empty -> .)
    PRIVATE         reduce using rule 118 (empty -> .)
    STATIC          reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    BOOLEAN         reduce using rule 118 (empty -> .)
    STRING          reduce using rule 118 (empty -> .)

    block                          shift and go to state 154
    empty                          shift and go to state 59

state 118

    (45) block -> LCURLY stmtlist RCURLY .

    RCURLY          reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    ID              reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    VOID            reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    PUBLIC          reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    PRIVATE         reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    STATIC          reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    INT             reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    FLOAT           reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    BOOLEAN         reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    STRING          reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    IF              reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    WHILE           reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    FOR             reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    RETURN          reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    BREAK           reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    CONTINUE        reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    SEMICOLON       reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    LCURLY          reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    PLUSPLUS        reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    MINUSMINUS      reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    THIS            reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    SUPER           reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    LPAREN          reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    NEW             reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    INTEGER         reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    STRING_LITERAL  reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    NULL            reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    FALSE           reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    TRUE            reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)
    ELSE            reduce using rule 45 (block -> LCURLY stmtlist RCURLY .)


state 119

    (48) stmtlist -> stmtlist stmt .

    RCURLY          reduce using rule 48 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 48 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 48 (stmtlist -> stmtlist stmt .)
    FOR             reduce using rule 48 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 48 (stmtlist -> stmtlist stmt .)
    BREAK           reduce using rule 48 (stmtlist -> stmtlist stmt .)
    CONTINUE        reduce using rule 48 (stmtlist -> stmtlist stmt .)
    SEMICOLON       reduce using rule 48 (stmtlist -> stmtlist stmt .)
    LCURLY          reduce using rule 48 (stmtlist -> stmtlist stmt .)
    PLUSPLUS        reduce using rule 48 (stmtlist -> stmtlist stmt .)
    MINUSMINUS      reduce using rule 48 (stmtlist -> stmtlist stmt .)
    INT             reduce using rule 48 (stmtlist -> stmtlist stmt .)
    FLOAT           reduce using rule 48 (stmtlist -> stmtlist stmt .)
    BOOLEAN         reduce using rule 48 (stmtlist -> stmtlist stmt .)
    STRING          reduce using rule 48 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 48 (stmtlist -> stmtlist stmt .)
    THIS            reduce using rule 48 (stmtlist -> stmtlist stmt .)
    SUPER           reduce using rule 48 (stmtlist -> stmtlist stmt .)
    LPAREN          reduce using rule 48 (stmtlist -> stmtlist stmt .)
    NEW             reduce using rule 48 (stmtlist -> stmtlist stmt .)
    INTEGER         reduce using rule 48 (stmtlist -> stmtlist stmt .)
    STRING_LITERAL  reduce using rule 48 (stmtlist -> stmtlist stmt .)
    NULL            reduce using rule 48 (stmtlist -> stmtlist stmt .)
    FALSE           reduce using rule 48 (stmtlist -> stmtlist stmt .)
    TRUE            reduce using rule 48 (stmtlist -> stmtlist stmt .)


state 120

    (49) stmt -> IF LPAREN . expression RPAREN stmt
    (50) stmt -> IF LPAREN . expression RPAREN stmt ELSE stmt
    (89) expression -> . primary
    (90) expression -> . assign
    (91) expression -> . expression arith_op expression
    (92) expression -> . expression bool_op expression
    (93) expression -> . unary_op expression
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (113) unary_op -> . PLUS
    (114) unary_op -> . MINUS
    (115) unary_op -> . NOT
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    NOT             shift and go to state 130
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105
    ID              shift and go to state 125

    expression                     shift and go to state 155
    primary                        shift and go to state 122
    assign                         shift and go to state 123
    unary_op                       shift and go to state 124
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126
    lhs                            shift and go to state 127
    field_access                   shift and go to state 93

state 121

    (77) primary -> LPAREN expression . RPAREN
    (91) expression -> expression . arith_op expression
    (92) expression -> expression . bool_op expression
    (101) arith_op -> . PLUS
    (102) arith_op -> . MINUS
    (103) arith_op -> . TIMES
    (104) arith_op -> . DIVIDE
    (105) bool_op -> . GREATER
    (106) bool_op -> . LESS
    (107) bool_op -> . GREATEREQ
    (108) bool_op -> . LESSEQ
    (109) bool_op -> . EQUAL
    (110) bool_op -> . NOTEQUAL
    (111) bool_op -> . AND
    (112) bool_op -> . OR

    RPAREN          shift and go to state 156
    PLUS            shift and go to state 159
    MINUS           shift and go to state 160
    TIMES           shift and go to state 161
    DIVIDE          shift and go to state 162
    GREATER         shift and go to state 163
    LESS            shift and go to state 164
    GREATEREQ       shift and go to state 165
    LESSEQ          shift and go to state 166
    EQUAL           shift and go to state 167
    NOTEQUAL        shift and go to state 168
    AND             shift and go to state 169
    OR              shift and go to state 170

    arith_op                       shift and go to state 157
    bool_op                        shift and go to state 158

state 122

    (89) expression -> primary .
    (85) field_access -> primary . DOT ID

    RPAREN          reduce using rule 89 (expression -> primary .)
    PLUS            reduce using rule 89 (expression -> primary .)
    MINUS           reduce using rule 89 (expression -> primary .)
    TIMES           reduce using rule 89 (expression -> primary .)
    DIVIDE          reduce using rule 89 (expression -> primary .)
    GREATER         reduce using rule 89 (expression -> primary .)
    LESS            reduce using rule 89 (expression -> primary .)
    GREATEREQ       reduce using rule 89 (expression -> primary .)
    LESSEQ          reduce using rule 89 (expression -> primary .)
    EQUAL           reduce using rule 89 (expression -> primary .)
    NOTEQUAL        reduce using rule 89 (expression -> primary .)
    AND             reduce using rule 89 (expression -> primary .)
    OR              reduce using rule 89 (expression -> primary .)
    SEMICOLON       reduce using rule 89 (expression -> primary .)
    COMMA           reduce using rule 89 (expression -> primary .)
    DOT             shift and go to state 146


state 123

    (90) expression -> assign .

    RPAREN          reduce using rule 90 (expression -> assign .)
    PLUS            reduce using rule 90 (expression -> assign .)
    MINUS           reduce using rule 90 (expression -> assign .)
    TIMES           reduce using rule 90 (expression -> assign .)
    DIVIDE          reduce using rule 90 (expression -> assign .)
    GREATER         reduce using rule 90 (expression -> assign .)
    LESS            reduce using rule 90 (expression -> assign .)
    GREATEREQ       reduce using rule 90 (expression -> assign .)
    LESSEQ          reduce using rule 90 (expression -> assign .)
    EQUAL           reduce using rule 90 (expression -> assign .)
    NOTEQUAL        reduce using rule 90 (expression -> assign .)
    AND             reduce using rule 90 (expression -> assign .)
    OR              reduce using rule 90 (expression -> assign .)
    SEMICOLON       reduce using rule 90 (expression -> assign .)
    COMMA           reduce using rule 90 (expression -> assign .)


state 124

    (93) expression -> unary_op . expression
    (89) expression -> . primary
    (90) expression -> . assign
    (91) expression -> . expression arith_op expression
    (92) expression -> . expression bool_op expression
    (93) expression -> . unary_op expression
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (113) unary_op -> . PLUS
    (114) unary_op -> . MINUS
    (115) unary_op -> . NOT
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    NOT             shift and go to state 130
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105
    ID              shift and go to state 125

    unary_op                       shift and go to state 124
    expression                     shift and go to state 171
    primary                        shift and go to state 122
    assign                         shift and go to state 123
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126
    lhs                            shift and go to state 127
    field_access                   shift and go to state 93

state 125

    (86) field_access -> ID .

    LPAREN          reduce using rule 86 (field_access -> ID .)
    SETEQUAL        reduce using rule 86 (field_access -> ID .)
    PLUSPLUS        reduce using rule 86 (field_access -> ID .)
    MINUSMINUS      reduce using rule 86 (field_access -> ID .)
    DOT             reduce using rule 86 (field_access -> ID .)
    RPAREN          reduce using rule 86 (field_access -> ID .)
    PLUS            reduce using rule 86 (field_access -> ID .)
    MINUS           reduce using rule 86 (field_access -> ID .)
    TIMES           reduce using rule 86 (field_access -> ID .)
    DIVIDE          reduce using rule 86 (field_access -> ID .)
    GREATER         reduce using rule 86 (field_access -> ID .)
    LESS            reduce using rule 86 (field_access -> ID .)
    GREATEREQ       reduce using rule 86 (field_access -> ID .)
    LESSEQ          reduce using rule 86 (field_access -> ID .)
    EQUAL           reduce using rule 86 (field_access -> ID .)
    NOTEQUAL        reduce using rule 86 (field_access -> ID .)
    AND             reduce using rule 86 (field_access -> ID .)
    OR              reduce using rule 86 (field_access -> ID .)
    SEMICOLON       reduce using rule 86 (field_access -> ID .)
    COMMA           reduce using rule 86 (field_access -> ID .)


state 126

    (80) primary -> method_invocation .

    DOT             reduce using rule 80 (primary -> method_invocation .)
    RPAREN          reduce using rule 80 (primary -> method_invocation .)
    PLUS            reduce using rule 80 (primary -> method_invocation .)
    MINUS           reduce using rule 80 (primary -> method_invocation .)
    TIMES           reduce using rule 80 (primary -> method_invocation .)
    DIVIDE          reduce using rule 80 (primary -> method_invocation .)
    GREATER         reduce using rule 80 (primary -> method_invocation .)
    LESS            reduce using rule 80 (primary -> method_invocation .)
    GREATEREQ       reduce using rule 80 (primary -> method_invocation .)
    LESSEQ          reduce using rule 80 (primary -> method_invocation .)
    EQUAL           reduce using rule 80 (primary -> method_invocation .)
    NOTEQUAL        reduce using rule 80 (primary -> method_invocation .)
    AND             reduce using rule 80 (primary -> method_invocation .)
    OR              reduce using rule 80 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 80 (primary -> method_invocation .)
    COMMA           reduce using rule 80 (primary -> method_invocation .)


state 127

    (81) primary -> lhs .
    (96) assign -> lhs . SETEQUAL expression
    (97) assign -> lhs . PLUSPLUS
    (98) assign -> lhs . MINUSMINUS

    DOT             reduce using rule 81 (primary -> lhs .)
    RPAREN          reduce using rule 81 (primary -> lhs .)
    PLUS            reduce using rule 81 (primary -> lhs .)
    MINUS           reduce using rule 81 (primary -> lhs .)
    TIMES           reduce using rule 81 (primary -> lhs .)
    DIVIDE          reduce using rule 81 (primary -> lhs .)
    GREATER         reduce using rule 81 (primary -> lhs .)
    LESS            reduce using rule 81 (primary -> lhs .)
    GREATEREQ       reduce using rule 81 (primary -> lhs .)
    LESSEQ          reduce using rule 81 (primary -> lhs .)
    EQUAL           reduce using rule 81 (primary -> lhs .)
    NOTEQUAL        reduce using rule 81 (primary -> lhs .)
    AND             reduce using rule 81 (primary -> lhs .)
    OR              reduce using rule 81 (primary -> lhs .)
    SEMICOLON       reduce using rule 81 (primary -> lhs .)
    COMMA           reduce using rule 81 (primary -> lhs .)
    SETEQUAL        shift and go to state 139
    PLUSPLUS        shift and go to state 140
    MINUSMINUS      shift and go to state 141


state 128

    (113) unary_op -> PLUS .

    THIS            reduce using rule 113 (unary_op -> PLUS .)
    SUPER           reduce using rule 113 (unary_op -> PLUS .)
    LPAREN          reduce using rule 113 (unary_op -> PLUS .)
    NEW             reduce using rule 113 (unary_op -> PLUS .)
    PLUSPLUS        reduce using rule 113 (unary_op -> PLUS .)
    MINUSMINUS      reduce using rule 113 (unary_op -> PLUS .)
    PLUS            reduce using rule 113 (unary_op -> PLUS .)
    MINUS           reduce using rule 113 (unary_op -> PLUS .)
    NOT             reduce using rule 113 (unary_op -> PLUS .)
    INTEGER         reduce using rule 113 (unary_op -> PLUS .)
    FLOAT           reduce using rule 113 (unary_op -> PLUS .)
    STRING_LITERAL  reduce using rule 113 (unary_op -> PLUS .)
    NULL            reduce using rule 113 (unary_op -> PLUS .)
    FALSE           reduce using rule 113 (unary_op -> PLUS .)
    TRUE            reduce using rule 113 (unary_op -> PLUS .)
    ID              reduce using rule 113 (unary_op -> PLUS .)


state 129

    (114) unary_op -> MINUS .

    THIS            reduce using rule 114 (unary_op -> MINUS .)
    SUPER           reduce using rule 114 (unary_op -> MINUS .)
    LPAREN          reduce using rule 114 (unary_op -> MINUS .)
    NEW             reduce using rule 114 (unary_op -> MINUS .)
    PLUSPLUS        reduce using rule 114 (unary_op -> MINUS .)
    MINUSMINUS      reduce using rule 114 (unary_op -> MINUS .)
    PLUS            reduce using rule 114 (unary_op -> MINUS .)
    MINUS           reduce using rule 114 (unary_op -> MINUS .)
    NOT             reduce using rule 114 (unary_op -> MINUS .)
    INTEGER         reduce using rule 114 (unary_op -> MINUS .)
    FLOAT           reduce using rule 114 (unary_op -> MINUS .)
    STRING_LITERAL  reduce using rule 114 (unary_op -> MINUS .)
    NULL            reduce using rule 114 (unary_op -> MINUS .)
    FALSE           reduce using rule 114 (unary_op -> MINUS .)
    TRUE            reduce using rule 114 (unary_op -> MINUS .)
    ID              reduce using rule 114 (unary_op -> MINUS .)


state 130

    (115) unary_op -> NOT .

    THIS            reduce using rule 115 (unary_op -> NOT .)
    SUPER           reduce using rule 115 (unary_op -> NOT .)
    LPAREN          reduce using rule 115 (unary_op -> NOT .)
    NEW             reduce using rule 115 (unary_op -> NOT .)
    PLUSPLUS        reduce using rule 115 (unary_op -> NOT .)
    MINUSMINUS      reduce using rule 115 (unary_op -> NOT .)
    PLUS            reduce using rule 115 (unary_op -> NOT .)
    MINUS           reduce using rule 115 (unary_op -> NOT .)
    NOT             reduce using rule 115 (unary_op -> NOT .)
    INTEGER         reduce using rule 115 (unary_op -> NOT .)
    FLOAT           reduce using rule 115 (unary_op -> NOT .)
    STRING_LITERAL  reduce using rule 115 (unary_op -> NOT .)
    NULL            reduce using rule 115 (unary_op -> NOT .)
    FALSE           reduce using rule 115 (unary_op -> NOT .)
    TRUE            reduce using rule 115 (unary_op -> NOT .)
    ID              reduce using rule 115 (unary_op -> NOT .)


state 131

    (69) literal -> FLOAT .

    DOT             reduce using rule 69 (literal -> FLOAT .)
    RPAREN          reduce using rule 69 (literal -> FLOAT .)
    PLUS            reduce using rule 69 (literal -> FLOAT .)
    MINUS           reduce using rule 69 (literal -> FLOAT .)
    TIMES           reduce using rule 69 (literal -> FLOAT .)
    DIVIDE          reduce using rule 69 (literal -> FLOAT .)
    GREATER         reduce using rule 69 (literal -> FLOAT .)
    LESS            reduce using rule 69 (literal -> FLOAT .)
    GREATEREQ       reduce using rule 69 (literal -> FLOAT .)
    LESSEQ          reduce using rule 69 (literal -> FLOAT .)
    EQUAL           reduce using rule 69 (literal -> FLOAT .)
    NOTEQUAL        reduce using rule 69 (literal -> FLOAT .)
    AND             reduce using rule 69 (literal -> FLOAT .)
    OR              reduce using rule 69 (literal -> FLOAT .)
    SEMICOLON       reduce using rule 69 (literal -> FLOAT .)
    COMMA           reduce using rule 69 (literal -> FLOAT .)


state 132

    (51) stmt -> WHILE LPAREN . expression RPAREN stmt
    (89) expression -> . primary
    (90) expression -> . assign
    (91) expression -> . expression arith_op expression
    (92) expression -> . expression bool_op expression
    (93) expression -> . unary_op expression
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (113) unary_op -> . PLUS
    (114) unary_op -> . MINUS
    (115) unary_op -> . NOT
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    NOT             shift and go to state 130
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105
    ID              shift and go to state 125

    expression                     shift and go to state 172
    primary                        shift and go to state 122
    assign                         shift and go to state 123
    unary_op                       shift and go to state 124
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126
    lhs                            shift and go to state 127
    field_access                   shift and go to state 93

state 133

    (52) stmt -> FOR LPAREN . stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> FOR LPAREN . stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> FOR LPAREN . stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> FOR LPAREN . SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> FOR LPAREN . stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> FOR LPAREN . SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> FOR LPAREN . SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> FOR LPAREN . SEMICOLON SEMICOLON RPAREN stmt
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

    SEMICOLON       shift and go to state 174
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ID              shift and go to state 125
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

    stmt_expression                shift and go to state 173
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 134

    (62) stmt -> stmt_expression SEMICOLON .

    RCURLY          reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    IF              reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    WHILE           reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    FOR             reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    RETURN          reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    BREAK           reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    CONTINUE        reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    SEMICOLON       reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    LCURLY          reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    PLUSPLUS        reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    MINUSMINUS      reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    INT             reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    FLOAT           reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    BOOLEAN         reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    STRING          reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    ID              reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    THIS            reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    SUPER           reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    LPAREN          reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    NEW             reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    INTEGER         reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    STRING_LITERAL  reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    NULL            reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    FALSE           reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    TRUE            reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)
    ELSE            reduce using rule 62 (stmt -> stmt_expression SEMICOLON .)


state 135

    (60) stmt -> RETURN expression . SEMICOLON
    (91) expression -> expression . arith_op expression
    (92) expression -> expression . bool_op expression
    (101) arith_op -> . PLUS
    (102) arith_op -> . MINUS
    (103) arith_op -> . TIMES
    (104) arith_op -> . DIVIDE
    (105) bool_op -> . GREATER
    (106) bool_op -> . LESS
    (107) bool_op -> . GREATEREQ
    (108) bool_op -> . LESSEQ
    (109) bool_op -> . EQUAL
    (110) bool_op -> . NOTEQUAL
    (111) bool_op -> . AND
    (112) bool_op -> . OR

    SEMICOLON       shift and go to state 175
    PLUS            shift and go to state 159
    MINUS           shift and go to state 160
    TIMES           shift and go to state 161
    DIVIDE          shift and go to state 162
    GREATER         shift and go to state 163
    LESS            shift and go to state 164
    GREATEREQ       shift and go to state 165
    LESSEQ          shift and go to state 166
    EQUAL           shift and go to state 167
    NOTEQUAL        shift and go to state 168
    AND             shift and go to state 169
    OR              shift and go to state 170

    arith_op                       shift and go to state 157
    bool_op                        shift and go to state 158

state 136

    (61) stmt -> RETURN SEMICOLON .

    RCURLY          reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    LCURLY          reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    PLUSPLUS        reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    MINUSMINUS      reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    INT             reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    BOOLEAN         reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    STRING          reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    ID              reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    THIS            reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    SUPER           reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    NEW             reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    INTEGER         reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    STRING_LITERAL  reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    NULL            reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    FALSE           reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    TRUE            reduce using rule 61 (stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 61 (stmt -> RETURN SEMICOLON .)


state 137

    (63) stmt -> BREAK SEMICOLON .

    RCURLY          reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    LCURLY          reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    PLUSPLUS        reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    MINUSMINUS      reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    STRING          reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    THIS            reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    SUPER           reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    INTEGER         reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    STRING_LITERAL  reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 63 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 63 (stmt -> BREAK SEMICOLON .)


state 138

    (64) stmt -> CONTINUE SEMICOLON .

    RCURLY          reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    LCURLY          reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    PLUSPLUS        reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    MINUSMINUS      reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    STRING          reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    SUPER           reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    INTEGER         reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    STRING_LITERAL  reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 64 (stmt -> CONTINUE SEMICOLON .)


state 139

    (96) assign -> lhs SETEQUAL . expression
    (89) expression -> . primary
    (90) expression -> . assign
    (91) expression -> . expression arith_op expression
    (92) expression -> . expression bool_op expression
    (93) expression -> . unary_op expression
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (113) unary_op -> . PLUS
    (114) unary_op -> . MINUS
    (115) unary_op -> . NOT
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    NOT             shift and go to state 130
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105
    ID              shift and go to state 125

    lhs                            shift and go to state 127
    expression                     shift and go to state 176
    primary                        shift and go to state 122
    assign                         shift and go to state 123
    unary_op                       shift and go to state 124
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126
    field_access                   shift and go to state 93

state 140

    (97) assign -> lhs PLUSPLUS .

    SEMICOLON       reduce using rule 97 (assign -> lhs PLUSPLUS .)
    RPAREN          reduce using rule 97 (assign -> lhs PLUSPLUS .)
    PLUS            reduce using rule 97 (assign -> lhs PLUSPLUS .)
    MINUS           reduce using rule 97 (assign -> lhs PLUSPLUS .)
    TIMES           reduce using rule 97 (assign -> lhs PLUSPLUS .)
    DIVIDE          reduce using rule 97 (assign -> lhs PLUSPLUS .)
    GREATER         reduce using rule 97 (assign -> lhs PLUSPLUS .)
    LESS            reduce using rule 97 (assign -> lhs PLUSPLUS .)
    GREATEREQ       reduce using rule 97 (assign -> lhs PLUSPLUS .)
    LESSEQ          reduce using rule 97 (assign -> lhs PLUSPLUS .)
    EQUAL           reduce using rule 97 (assign -> lhs PLUSPLUS .)
    NOTEQUAL        reduce using rule 97 (assign -> lhs PLUSPLUS .)
    AND             reduce using rule 97 (assign -> lhs PLUSPLUS .)
    OR              reduce using rule 97 (assign -> lhs PLUSPLUS .)
    COMMA           reduce using rule 97 (assign -> lhs PLUSPLUS .)


state 141

    (98) assign -> lhs MINUSMINUS .

    SEMICOLON       reduce using rule 98 (assign -> lhs MINUSMINUS .)
    RPAREN          reduce using rule 98 (assign -> lhs MINUSMINUS .)
    PLUS            reduce using rule 98 (assign -> lhs MINUSMINUS .)
    MINUS           reduce using rule 98 (assign -> lhs MINUSMINUS .)
    TIMES           reduce using rule 98 (assign -> lhs MINUSMINUS .)
    DIVIDE          reduce using rule 98 (assign -> lhs MINUSMINUS .)
    GREATER         reduce using rule 98 (assign -> lhs MINUSMINUS .)
    LESS            reduce using rule 98 (assign -> lhs MINUSMINUS .)
    GREATEREQ       reduce using rule 98 (assign -> lhs MINUSMINUS .)
    LESSEQ          reduce using rule 98 (assign -> lhs MINUSMINUS .)
    EQUAL           reduce using rule 98 (assign -> lhs MINUSMINUS .)
    NOTEQUAL        reduce using rule 98 (assign -> lhs MINUSMINUS .)
    AND             reduce using rule 98 (assign -> lhs MINUSMINUS .)
    OR              reduce using rule 98 (assign -> lhs MINUSMINUS .)
    COMMA           reduce using rule 98 (assign -> lhs MINUSMINUS .)


state 142

    (99) assign -> PLUSPLUS lhs .
    (81) primary -> lhs .

    SEMICOLON       reduce using rule 99 (assign -> PLUSPLUS lhs .)
    RPAREN          reduce using rule 99 (assign -> PLUSPLUS lhs .)
    PLUS            reduce using rule 99 (assign -> PLUSPLUS lhs .)
    MINUS           reduce using rule 99 (assign -> PLUSPLUS lhs .)
    TIMES           reduce using rule 99 (assign -> PLUSPLUS lhs .)
    DIVIDE          reduce using rule 99 (assign -> PLUSPLUS lhs .)
    GREATER         reduce using rule 99 (assign -> PLUSPLUS lhs .)
    LESS            reduce using rule 99 (assign -> PLUSPLUS lhs .)
    GREATEREQ       reduce using rule 99 (assign -> PLUSPLUS lhs .)
    LESSEQ          reduce using rule 99 (assign -> PLUSPLUS lhs .)
    EQUAL           reduce using rule 99 (assign -> PLUSPLUS lhs .)
    NOTEQUAL        reduce using rule 99 (assign -> PLUSPLUS lhs .)
    AND             reduce using rule 99 (assign -> PLUSPLUS lhs .)
    OR              reduce using rule 99 (assign -> PLUSPLUS lhs .)
    COMMA           reduce using rule 99 (assign -> PLUSPLUS lhs .)
    DOT             reduce using rule 81 (primary -> lhs .)


state 143

    (84) lhs -> field_access .
    (87) method_invocation -> field_access . LPAREN arguments RPAREN
    (88) method_invocation -> field_access . LPAREN RPAREN

    SEMICOLON       reduce using rule 84 (lhs -> field_access .)
    RPAREN          reduce using rule 84 (lhs -> field_access .)
    PLUS            reduce using rule 84 (lhs -> field_access .)
    MINUS           reduce using rule 84 (lhs -> field_access .)
    TIMES           reduce using rule 84 (lhs -> field_access .)
    DIVIDE          reduce using rule 84 (lhs -> field_access .)
    GREATER         reduce using rule 84 (lhs -> field_access .)
    LESS            reduce using rule 84 (lhs -> field_access .)
    GREATEREQ       reduce using rule 84 (lhs -> field_access .)
    LESSEQ          reduce using rule 84 (lhs -> field_access .)
    EQUAL           reduce using rule 84 (lhs -> field_access .)
    NOTEQUAL        reduce using rule 84 (lhs -> field_access .)
    AND             reduce using rule 84 (lhs -> field_access .)
    OR              reduce using rule 84 (lhs -> field_access .)
    DOT             reduce using rule 84 (lhs -> field_access .)
    COMMA           reduce using rule 84 (lhs -> field_access .)
    LPAREN          shift and go to state 145


state 144

    (100) assign -> MINUSMINUS lhs .
    (81) primary -> lhs .

    SEMICOLON       reduce using rule 100 (assign -> MINUSMINUS lhs .)
    RPAREN          reduce using rule 100 (assign -> MINUSMINUS lhs .)
    PLUS            reduce using rule 100 (assign -> MINUSMINUS lhs .)
    MINUS           reduce using rule 100 (assign -> MINUSMINUS lhs .)
    TIMES           reduce using rule 100 (assign -> MINUSMINUS lhs .)
    DIVIDE          reduce using rule 100 (assign -> MINUSMINUS lhs .)
    GREATER         reduce using rule 100 (assign -> MINUSMINUS lhs .)
    LESS            reduce using rule 100 (assign -> MINUSMINUS lhs .)
    GREATEREQ       reduce using rule 100 (assign -> MINUSMINUS lhs .)
    LESSEQ          reduce using rule 100 (assign -> MINUSMINUS lhs .)
    EQUAL           reduce using rule 100 (assign -> MINUSMINUS lhs .)
    NOTEQUAL        reduce using rule 100 (assign -> MINUSMINUS lhs .)
    AND             reduce using rule 100 (assign -> MINUSMINUS lhs .)
    OR              reduce using rule 100 (assign -> MINUSMINUS lhs .)
    COMMA           reduce using rule 100 (assign -> MINUSMINUS lhs .)
    DOT             reduce using rule 81 (primary -> lhs .)


state 145

    (87) method_invocation -> field_access LPAREN . arguments RPAREN
    (88) method_invocation -> field_access LPAREN . RPAREN
    (82) arguments -> . expression
    (83) arguments -> . expression COMMA arguments
    (89) expression -> . primary
    (90) expression -> . assign
    (91) expression -> . expression arith_op expression
    (92) expression -> . expression bool_op expression
    (93) expression -> . unary_op expression
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (113) unary_op -> . PLUS
    (114) unary_op -> . MINUS
    (115) unary_op -> . NOT
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID

    RPAREN          shift and go to state 178
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    NOT             shift and go to state 130
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105
    ID              shift and go to state 125

    field_access                   shift and go to state 93
    arguments                      shift and go to state 177
    expression                     shift and go to state 179
    primary                        shift and go to state 122
    assign                         shift and go to state 123
    unary_op                       shift and go to state 124
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126
    lhs                            shift and go to state 127

state 146

    (85) field_access -> primary DOT . ID

    ID              shift and go to state 180


state 147

    (78) primary -> NEW ID . LPAREN RPAREN
    (79) primary -> NEW ID . LPAREN arguments RPAREN

    LPAREN          shift and go to state 181


state 148

    (39) constructor_decl -> modifier ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 39 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    ID              reduce using rule 39 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 39 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 39 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 39 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 39 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    INT             reduce using rule 39 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 39 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 39 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    STRING          reduce using rule 39 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)


state 149

    (30) method_decl -> modifier type ID LPAREN RPAREN block .

    RCURLY          reduce using rule 30 (method_decl -> modifier type ID LPAREN RPAREN block .)
    ID              reduce using rule 30 (method_decl -> modifier type ID LPAREN RPAREN block .)
    VOID            reduce using rule 30 (method_decl -> modifier type ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 30 (method_decl -> modifier type ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 30 (method_decl -> modifier type ID LPAREN RPAREN block .)
    STATIC          reduce using rule 30 (method_decl -> modifier type ID LPAREN RPAREN block .)
    INT             reduce using rule 30 (method_decl -> modifier type ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 30 (method_decl -> modifier type ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 30 (method_decl -> modifier type ID LPAREN RPAREN block .)
    STRING          reduce using rule 30 (method_decl -> modifier type ID LPAREN RPAREN block .)


state 150

    (31) method_decl -> modifier type ID LPAREN formals RPAREN . block
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (118) empty -> .

    LCURLY          shift and go to state 58
    RCURLY          reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    PUBLIC          reduce using rule 118 (empty -> .)
    PRIVATE         reduce using rule 118 (empty -> .)
    STATIC          reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    BOOLEAN         reduce using rule 118 (empty -> .)
    STRING          reduce using rule 118 (empty -> .)

    block                          shift and go to state 182
    empty                          shift and go to state 59

state 151

    (32) method_decl -> modifier VOID ID LPAREN RPAREN block .

    RCURLY          reduce using rule 32 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    ID              reduce using rule 32 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    VOID            reduce using rule 32 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 32 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 32 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    STATIC          reduce using rule 32 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    INT             reduce using rule 32 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 32 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 32 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    STRING          reduce using rule 32 (method_decl -> modifier VOID ID LPAREN RPAREN block .)


state 152

    (33) method_decl -> modifier VOID ID LPAREN formals RPAREN . block
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (118) empty -> .

    LCURLY          shift and go to state 58
    RCURLY          reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)
    VOID            reduce using rule 118 (empty -> .)
    PUBLIC          reduce using rule 118 (empty -> .)
    PRIVATE         reduce using rule 118 (empty -> .)
    STATIC          reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    BOOLEAN         reduce using rule 118 (empty -> .)
    STRING          reduce using rule 118 (empty -> .)

    block                          shift and go to state 183
    empty                          shift and go to state 59

state 153

    (35) method_decl -> type ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 35 (method_decl -> type ID LPAREN formals RPAREN block .)
    ID              reduce using rule 35 (method_decl -> type ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 35 (method_decl -> type ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 35 (method_decl -> type ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 35 (method_decl -> type ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 35 (method_decl -> type ID LPAREN formals RPAREN block .)
    INT             reduce using rule 35 (method_decl -> type ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 35 (method_decl -> type ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 35 (method_decl -> type ID LPAREN formals RPAREN block .)
    STRING          reduce using rule 35 (method_decl -> type ID LPAREN formals RPAREN block .)


state 154

    (37) method_decl -> VOID ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 37 (method_decl -> VOID ID LPAREN formals RPAREN block .)
    ID              reduce using rule 37 (method_decl -> VOID ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 37 (method_decl -> VOID ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 37 (method_decl -> VOID ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 37 (method_decl -> VOID ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 37 (method_decl -> VOID ID LPAREN formals RPAREN block .)
    INT             reduce using rule 37 (method_decl -> VOID ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 37 (method_decl -> VOID ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 37 (method_decl -> VOID ID LPAREN formals RPAREN block .)
    STRING          reduce using rule 37 (method_decl -> VOID ID LPAREN formals RPAREN block .)


state 155

    (49) stmt -> IF LPAREN expression . RPAREN stmt
    (50) stmt -> IF LPAREN expression . RPAREN stmt ELSE stmt
    (91) expression -> expression . arith_op expression
    (92) expression -> expression . bool_op expression
    (101) arith_op -> . PLUS
    (102) arith_op -> . MINUS
    (103) arith_op -> . TIMES
    (104) arith_op -> . DIVIDE
    (105) bool_op -> . GREATER
    (106) bool_op -> . LESS
    (107) bool_op -> . GREATEREQ
    (108) bool_op -> . LESSEQ
    (109) bool_op -> . EQUAL
    (110) bool_op -> . NOTEQUAL
    (111) bool_op -> . AND
    (112) bool_op -> . OR

    RPAREN          shift and go to state 184
    PLUS            shift and go to state 159
    MINUS           shift and go to state 160
    TIMES           shift and go to state 161
    DIVIDE          shift and go to state 162
    GREATER         shift and go to state 163
    LESS            shift and go to state 164
    GREATEREQ       shift and go to state 165
    LESSEQ          shift and go to state 166
    EQUAL           shift and go to state 167
    NOTEQUAL        shift and go to state 168
    AND             shift and go to state 169
    OR              shift and go to state 170

    arith_op                       shift and go to state 157
    bool_op                        shift and go to state 158

state 156

    (77) primary -> LPAREN expression RPAREN .

    DOT             reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    LESS            reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    GREATEREQ       reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    LESSEQ          reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    NOTEQUAL        reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    AND             reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    OR              reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 77 (primary -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 77 (primary -> LPAREN expression RPAREN .)


state 157

    (91) expression -> expression arith_op . expression
    (89) expression -> . primary
    (90) expression -> . assign
    (91) expression -> . expression arith_op expression
    (92) expression -> . expression bool_op expression
    (93) expression -> . unary_op expression
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (113) unary_op -> . PLUS
    (114) unary_op -> . MINUS
    (115) unary_op -> . NOT
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    NOT             shift and go to state 130
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105
    ID              shift and go to state 125

    expression                     shift and go to state 185
    primary                        shift and go to state 122
    assign                         shift and go to state 123
    unary_op                       shift and go to state 124
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126
    lhs                            shift and go to state 127
    field_access                   shift and go to state 93

state 158

    (92) expression -> expression bool_op . expression
    (89) expression -> . primary
    (90) expression -> . assign
    (91) expression -> . expression arith_op expression
    (92) expression -> . expression bool_op expression
    (93) expression -> . unary_op expression
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (113) unary_op -> . PLUS
    (114) unary_op -> . MINUS
    (115) unary_op -> . NOT
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    NOT             shift and go to state 130
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105
    ID              shift and go to state 125

    expression                     shift and go to state 186
    primary                        shift and go to state 122
    assign                         shift and go to state 123
    unary_op                       shift and go to state 124
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126
    lhs                            shift and go to state 127
    field_access                   shift and go to state 93

state 159

    (101) arith_op -> PLUS .

    THIS            reduce using rule 101 (arith_op -> PLUS .)
    SUPER           reduce using rule 101 (arith_op -> PLUS .)
    LPAREN          reduce using rule 101 (arith_op -> PLUS .)
    NEW             reduce using rule 101 (arith_op -> PLUS .)
    PLUSPLUS        reduce using rule 101 (arith_op -> PLUS .)
    MINUSMINUS      reduce using rule 101 (arith_op -> PLUS .)
    PLUS            reduce using rule 101 (arith_op -> PLUS .)
    MINUS           reduce using rule 101 (arith_op -> PLUS .)
    NOT             reduce using rule 101 (arith_op -> PLUS .)
    INTEGER         reduce using rule 101 (arith_op -> PLUS .)
    FLOAT           reduce using rule 101 (arith_op -> PLUS .)
    STRING_LITERAL  reduce using rule 101 (arith_op -> PLUS .)
    NULL            reduce using rule 101 (arith_op -> PLUS .)
    FALSE           reduce using rule 101 (arith_op -> PLUS .)
    TRUE            reduce using rule 101 (arith_op -> PLUS .)
    ID              reduce using rule 101 (arith_op -> PLUS .)


state 160

    (102) arith_op -> MINUS .

    THIS            reduce using rule 102 (arith_op -> MINUS .)
    SUPER           reduce using rule 102 (arith_op -> MINUS .)
    LPAREN          reduce using rule 102 (arith_op -> MINUS .)
    NEW             reduce using rule 102 (arith_op -> MINUS .)
    PLUSPLUS        reduce using rule 102 (arith_op -> MINUS .)
    MINUSMINUS      reduce using rule 102 (arith_op -> MINUS .)
    PLUS            reduce using rule 102 (arith_op -> MINUS .)
    MINUS           reduce using rule 102 (arith_op -> MINUS .)
    NOT             reduce using rule 102 (arith_op -> MINUS .)
    INTEGER         reduce using rule 102 (arith_op -> MINUS .)
    FLOAT           reduce using rule 102 (arith_op -> MINUS .)
    STRING_LITERAL  reduce using rule 102 (arith_op -> MINUS .)
    NULL            reduce using rule 102 (arith_op -> MINUS .)
    FALSE           reduce using rule 102 (arith_op -> MINUS .)
    TRUE            reduce using rule 102 (arith_op -> MINUS .)
    ID              reduce using rule 102 (arith_op -> MINUS .)


state 161

    (103) arith_op -> TIMES .

    THIS            reduce using rule 103 (arith_op -> TIMES .)
    SUPER           reduce using rule 103 (arith_op -> TIMES .)
    LPAREN          reduce using rule 103 (arith_op -> TIMES .)
    NEW             reduce using rule 103 (arith_op -> TIMES .)
    PLUSPLUS        reduce using rule 103 (arith_op -> TIMES .)
    MINUSMINUS      reduce using rule 103 (arith_op -> TIMES .)
    PLUS            reduce using rule 103 (arith_op -> TIMES .)
    MINUS           reduce using rule 103 (arith_op -> TIMES .)
    NOT             reduce using rule 103 (arith_op -> TIMES .)
    INTEGER         reduce using rule 103 (arith_op -> TIMES .)
    FLOAT           reduce using rule 103 (arith_op -> TIMES .)
    STRING_LITERAL  reduce using rule 103 (arith_op -> TIMES .)
    NULL            reduce using rule 103 (arith_op -> TIMES .)
    FALSE           reduce using rule 103 (arith_op -> TIMES .)
    TRUE            reduce using rule 103 (arith_op -> TIMES .)
    ID              reduce using rule 103 (arith_op -> TIMES .)


state 162

    (104) arith_op -> DIVIDE .

    THIS            reduce using rule 104 (arith_op -> DIVIDE .)
    SUPER           reduce using rule 104 (arith_op -> DIVIDE .)
    LPAREN          reduce using rule 104 (arith_op -> DIVIDE .)
    NEW             reduce using rule 104 (arith_op -> DIVIDE .)
    PLUSPLUS        reduce using rule 104 (arith_op -> DIVIDE .)
    MINUSMINUS      reduce using rule 104 (arith_op -> DIVIDE .)
    PLUS            reduce using rule 104 (arith_op -> DIVIDE .)
    MINUS           reduce using rule 104 (arith_op -> DIVIDE .)
    NOT             reduce using rule 104 (arith_op -> DIVIDE .)
    INTEGER         reduce using rule 104 (arith_op -> DIVIDE .)
    FLOAT           reduce using rule 104 (arith_op -> DIVIDE .)
    STRING_LITERAL  reduce using rule 104 (arith_op -> DIVIDE .)
    NULL            reduce using rule 104 (arith_op -> DIVIDE .)
    FALSE           reduce using rule 104 (arith_op -> DIVIDE .)
    TRUE            reduce using rule 104 (arith_op -> DIVIDE .)
    ID              reduce using rule 104 (arith_op -> DIVIDE .)


state 163

    (105) bool_op -> GREATER .

    THIS            reduce using rule 105 (bool_op -> GREATER .)
    SUPER           reduce using rule 105 (bool_op -> GREATER .)
    LPAREN          reduce using rule 105 (bool_op -> GREATER .)
    NEW             reduce using rule 105 (bool_op -> GREATER .)
    PLUSPLUS        reduce using rule 105 (bool_op -> GREATER .)
    MINUSMINUS      reduce using rule 105 (bool_op -> GREATER .)
    PLUS            reduce using rule 105 (bool_op -> GREATER .)
    MINUS           reduce using rule 105 (bool_op -> GREATER .)
    NOT             reduce using rule 105 (bool_op -> GREATER .)
    INTEGER         reduce using rule 105 (bool_op -> GREATER .)
    FLOAT           reduce using rule 105 (bool_op -> GREATER .)
    STRING_LITERAL  reduce using rule 105 (bool_op -> GREATER .)
    NULL            reduce using rule 105 (bool_op -> GREATER .)
    FALSE           reduce using rule 105 (bool_op -> GREATER .)
    TRUE            reduce using rule 105 (bool_op -> GREATER .)
    ID              reduce using rule 105 (bool_op -> GREATER .)


state 164

    (106) bool_op -> LESS .

    THIS            reduce using rule 106 (bool_op -> LESS .)
    SUPER           reduce using rule 106 (bool_op -> LESS .)
    LPAREN          reduce using rule 106 (bool_op -> LESS .)
    NEW             reduce using rule 106 (bool_op -> LESS .)
    PLUSPLUS        reduce using rule 106 (bool_op -> LESS .)
    MINUSMINUS      reduce using rule 106 (bool_op -> LESS .)
    PLUS            reduce using rule 106 (bool_op -> LESS .)
    MINUS           reduce using rule 106 (bool_op -> LESS .)
    NOT             reduce using rule 106 (bool_op -> LESS .)
    INTEGER         reduce using rule 106 (bool_op -> LESS .)
    FLOAT           reduce using rule 106 (bool_op -> LESS .)
    STRING_LITERAL  reduce using rule 106 (bool_op -> LESS .)
    NULL            reduce using rule 106 (bool_op -> LESS .)
    FALSE           reduce using rule 106 (bool_op -> LESS .)
    TRUE            reduce using rule 106 (bool_op -> LESS .)
    ID              reduce using rule 106 (bool_op -> LESS .)


state 165

    (107) bool_op -> GREATEREQ .

    THIS            reduce using rule 107 (bool_op -> GREATEREQ .)
    SUPER           reduce using rule 107 (bool_op -> GREATEREQ .)
    LPAREN          reduce using rule 107 (bool_op -> GREATEREQ .)
    NEW             reduce using rule 107 (bool_op -> GREATEREQ .)
    PLUSPLUS        reduce using rule 107 (bool_op -> GREATEREQ .)
    MINUSMINUS      reduce using rule 107 (bool_op -> GREATEREQ .)
    PLUS            reduce using rule 107 (bool_op -> GREATEREQ .)
    MINUS           reduce using rule 107 (bool_op -> GREATEREQ .)
    NOT             reduce using rule 107 (bool_op -> GREATEREQ .)
    INTEGER         reduce using rule 107 (bool_op -> GREATEREQ .)
    FLOAT           reduce using rule 107 (bool_op -> GREATEREQ .)
    STRING_LITERAL  reduce using rule 107 (bool_op -> GREATEREQ .)
    NULL            reduce using rule 107 (bool_op -> GREATEREQ .)
    FALSE           reduce using rule 107 (bool_op -> GREATEREQ .)
    TRUE            reduce using rule 107 (bool_op -> GREATEREQ .)
    ID              reduce using rule 107 (bool_op -> GREATEREQ .)


state 166

    (108) bool_op -> LESSEQ .

    THIS            reduce using rule 108 (bool_op -> LESSEQ .)
    SUPER           reduce using rule 108 (bool_op -> LESSEQ .)
    LPAREN          reduce using rule 108 (bool_op -> LESSEQ .)
    NEW             reduce using rule 108 (bool_op -> LESSEQ .)
    PLUSPLUS        reduce using rule 108 (bool_op -> LESSEQ .)
    MINUSMINUS      reduce using rule 108 (bool_op -> LESSEQ .)
    PLUS            reduce using rule 108 (bool_op -> LESSEQ .)
    MINUS           reduce using rule 108 (bool_op -> LESSEQ .)
    NOT             reduce using rule 108 (bool_op -> LESSEQ .)
    INTEGER         reduce using rule 108 (bool_op -> LESSEQ .)
    FLOAT           reduce using rule 108 (bool_op -> LESSEQ .)
    STRING_LITERAL  reduce using rule 108 (bool_op -> LESSEQ .)
    NULL            reduce using rule 108 (bool_op -> LESSEQ .)
    FALSE           reduce using rule 108 (bool_op -> LESSEQ .)
    TRUE            reduce using rule 108 (bool_op -> LESSEQ .)
    ID              reduce using rule 108 (bool_op -> LESSEQ .)


state 167

    (109) bool_op -> EQUAL .

    THIS            reduce using rule 109 (bool_op -> EQUAL .)
    SUPER           reduce using rule 109 (bool_op -> EQUAL .)
    LPAREN          reduce using rule 109 (bool_op -> EQUAL .)
    NEW             reduce using rule 109 (bool_op -> EQUAL .)
    PLUSPLUS        reduce using rule 109 (bool_op -> EQUAL .)
    MINUSMINUS      reduce using rule 109 (bool_op -> EQUAL .)
    PLUS            reduce using rule 109 (bool_op -> EQUAL .)
    MINUS           reduce using rule 109 (bool_op -> EQUAL .)
    NOT             reduce using rule 109 (bool_op -> EQUAL .)
    INTEGER         reduce using rule 109 (bool_op -> EQUAL .)
    FLOAT           reduce using rule 109 (bool_op -> EQUAL .)
    STRING_LITERAL  reduce using rule 109 (bool_op -> EQUAL .)
    NULL            reduce using rule 109 (bool_op -> EQUAL .)
    FALSE           reduce using rule 109 (bool_op -> EQUAL .)
    TRUE            reduce using rule 109 (bool_op -> EQUAL .)
    ID              reduce using rule 109 (bool_op -> EQUAL .)


state 168

    (110) bool_op -> NOTEQUAL .

    THIS            reduce using rule 110 (bool_op -> NOTEQUAL .)
    SUPER           reduce using rule 110 (bool_op -> NOTEQUAL .)
    LPAREN          reduce using rule 110 (bool_op -> NOTEQUAL .)
    NEW             reduce using rule 110 (bool_op -> NOTEQUAL .)
    PLUSPLUS        reduce using rule 110 (bool_op -> NOTEQUAL .)
    MINUSMINUS      reduce using rule 110 (bool_op -> NOTEQUAL .)
    PLUS            reduce using rule 110 (bool_op -> NOTEQUAL .)
    MINUS           reduce using rule 110 (bool_op -> NOTEQUAL .)
    NOT             reduce using rule 110 (bool_op -> NOTEQUAL .)
    INTEGER         reduce using rule 110 (bool_op -> NOTEQUAL .)
    FLOAT           reduce using rule 110 (bool_op -> NOTEQUAL .)
    STRING_LITERAL  reduce using rule 110 (bool_op -> NOTEQUAL .)
    NULL            reduce using rule 110 (bool_op -> NOTEQUAL .)
    FALSE           reduce using rule 110 (bool_op -> NOTEQUAL .)
    TRUE            reduce using rule 110 (bool_op -> NOTEQUAL .)
    ID              reduce using rule 110 (bool_op -> NOTEQUAL .)


state 169

    (111) bool_op -> AND .

    THIS            reduce using rule 111 (bool_op -> AND .)
    SUPER           reduce using rule 111 (bool_op -> AND .)
    LPAREN          reduce using rule 111 (bool_op -> AND .)
    NEW             reduce using rule 111 (bool_op -> AND .)
    PLUSPLUS        reduce using rule 111 (bool_op -> AND .)
    MINUSMINUS      reduce using rule 111 (bool_op -> AND .)
    PLUS            reduce using rule 111 (bool_op -> AND .)
    MINUS           reduce using rule 111 (bool_op -> AND .)
    NOT             reduce using rule 111 (bool_op -> AND .)
    INTEGER         reduce using rule 111 (bool_op -> AND .)
    FLOAT           reduce using rule 111 (bool_op -> AND .)
    STRING_LITERAL  reduce using rule 111 (bool_op -> AND .)
    NULL            reduce using rule 111 (bool_op -> AND .)
    FALSE           reduce using rule 111 (bool_op -> AND .)
    TRUE            reduce using rule 111 (bool_op -> AND .)
    ID              reduce using rule 111 (bool_op -> AND .)


state 170

    (112) bool_op -> OR .

    THIS            reduce using rule 112 (bool_op -> OR .)
    SUPER           reduce using rule 112 (bool_op -> OR .)
    LPAREN          reduce using rule 112 (bool_op -> OR .)
    NEW             reduce using rule 112 (bool_op -> OR .)
    PLUSPLUS        reduce using rule 112 (bool_op -> OR .)
    MINUSMINUS      reduce using rule 112 (bool_op -> OR .)
    PLUS            reduce using rule 112 (bool_op -> OR .)
    MINUS           reduce using rule 112 (bool_op -> OR .)
    NOT             reduce using rule 112 (bool_op -> OR .)
    INTEGER         reduce using rule 112 (bool_op -> OR .)
    FLOAT           reduce using rule 112 (bool_op -> OR .)
    STRING_LITERAL  reduce using rule 112 (bool_op -> OR .)
    NULL            reduce using rule 112 (bool_op -> OR .)
    FALSE           reduce using rule 112 (bool_op -> OR .)
    TRUE            reduce using rule 112 (bool_op -> OR .)
    ID              reduce using rule 112 (bool_op -> OR .)


state 171

    (93) expression -> unary_op expression .
    (91) expression -> expression . arith_op expression
    (92) expression -> expression . bool_op expression
    (101) arith_op -> . PLUS
    (102) arith_op -> . MINUS
    (103) arith_op -> . TIMES
    (104) arith_op -> . DIVIDE
    (105) bool_op -> . GREATER
    (106) bool_op -> . LESS
    (107) bool_op -> . GREATEREQ
    (108) bool_op -> . LESSEQ
    (109) bool_op -> . EQUAL
    (110) bool_op -> . NOTEQUAL
    (111) bool_op -> . AND
    (112) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 93 (expression -> unary_op expression .)
    SEMICOLON       reduce using rule 93 (expression -> unary_op expression .)
    COMMA           reduce using rule 93 (expression -> unary_op expression .)
    PLUS            shift and go to state 159
    MINUS           shift and go to state 160
    TIMES           shift and go to state 161
    DIVIDE          shift and go to state 162
    GREATER         shift and go to state 163
    LESS            shift and go to state 164
    GREATEREQ       shift and go to state 165
    LESSEQ          shift and go to state 166
    EQUAL           shift and go to state 167
    NOTEQUAL        shift and go to state 168
    AND             shift and go to state 169
    OR              shift and go to state 170

  ! PLUS            [ reduce using rule 93 (expression -> unary_op expression .) ]
  ! MINUS           [ reduce using rule 93 (expression -> unary_op expression .) ]
  ! TIMES           [ reduce using rule 93 (expression -> unary_op expression .) ]
  ! DIVIDE          [ reduce using rule 93 (expression -> unary_op expression .) ]
  ! GREATER         [ reduce using rule 93 (expression -> unary_op expression .) ]
  ! LESS            [ reduce using rule 93 (expression -> unary_op expression .) ]
  ! GREATEREQ       [ reduce using rule 93 (expression -> unary_op expression .) ]
  ! LESSEQ          [ reduce using rule 93 (expression -> unary_op expression .) ]
  ! EQUAL           [ reduce using rule 93 (expression -> unary_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 93 (expression -> unary_op expression .) ]
  ! AND             [ reduce using rule 93 (expression -> unary_op expression .) ]
  ! OR              [ reduce using rule 93 (expression -> unary_op expression .) ]

    arith_op                       shift and go to state 157
    bool_op                        shift and go to state 158

state 172

    (51) stmt -> WHILE LPAREN expression . RPAREN stmt
    (91) expression -> expression . arith_op expression
    (92) expression -> expression . bool_op expression
    (101) arith_op -> . PLUS
    (102) arith_op -> . MINUS
    (103) arith_op -> . TIMES
    (104) arith_op -> . DIVIDE
    (105) bool_op -> . GREATER
    (106) bool_op -> . LESS
    (107) bool_op -> . GREATEREQ
    (108) bool_op -> . LESSEQ
    (109) bool_op -> . EQUAL
    (110) bool_op -> . NOTEQUAL
    (111) bool_op -> . AND
    (112) bool_op -> . OR

    RPAREN          shift and go to state 187
    PLUS            shift and go to state 159
    MINUS           shift and go to state 160
    TIMES           shift and go to state 161
    DIVIDE          shift and go to state 162
    GREATER         shift and go to state 163
    LESS            shift and go to state 164
    GREATEREQ       shift and go to state 165
    LESSEQ          shift and go to state 166
    EQUAL           shift and go to state 167
    NOTEQUAL        shift and go to state 168
    AND             shift and go to state 169
    OR              shift and go to state 170

    arith_op                       shift and go to state 157
    bool_op                        shift and go to state 158

state 173

    (52) stmt -> FOR LPAREN stmt_expression . SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> FOR LPAREN stmt_expression . SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> FOR LPAREN stmt_expression . SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> FOR LPAREN stmt_expression . SEMICOLON SEMICOLON RPAREN stmt

    SEMICOLON       shift and go to state 188


state 174

    (55) stmt -> FOR LPAREN SEMICOLON . expression SEMICOLON stmt_expression RPAREN stmt
    (57) stmt -> FOR LPAREN SEMICOLON . SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> FOR LPAREN SEMICOLON . expression SEMICOLON RPAREN stmt
    (59) stmt -> FOR LPAREN SEMICOLON . SEMICOLON RPAREN stmt
    (89) expression -> . primary
    (90) expression -> . assign
    (91) expression -> . expression arith_op expression
    (92) expression -> . expression bool_op expression
    (93) expression -> . unary_op expression
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (113) unary_op -> . PLUS
    (114) unary_op -> . MINUS
    (115) unary_op -> . NOT
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID

    SEMICOLON       shift and go to state 189
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    NOT             shift and go to state 130
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105
    ID              shift and go to state 125

    expression                     shift and go to state 190
    primary                        shift and go to state 122
    assign                         shift and go to state 123
    unary_op                       shift and go to state 124
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126
    lhs                            shift and go to state 127
    field_access                   shift and go to state 93

state 175

    (60) stmt -> RETURN expression SEMICOLON .

    RCURLY          reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    IF              reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    BREAK           reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    CONTINUE        reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    SEMICOLON       reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    LCURLY          reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    PLUSPLUS        reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    MINUSMINUS      reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    INT             reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    BOOLEAN         reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    ID              reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    THIS            reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    SUPER           reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    NEW             reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    INTEGER         reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    STRING_LITERAL  reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    NULL            reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    FALSE           reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    TRUE            reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 60 (stmt -> RETURN expression SEMICOLON .)


state 176

    (96) assign -> lhs SETEQUAL expression .
    (91) expression -> expression . arith_op expression
    (92) expression -> expression . bool_op expression
    (101) arith_op -> . PLUS
    (102) arith_op -> . MINUS
    (103) arith_op -> . TIMES
    (104) arith_op -> . DIVIDE
    (105) bool_op -> . GREATER
    (106) bool_op -> . LESS
    (107) bool_op -> . GREATEREQ
    (108) bool_op -> . LESSEQ
    (109) bool_op -> . EQUAL
    (110) bool_op -> . NOTEQUAL
    (111) bool_op -> . AND
    (112) bool_op -> . OR

    SEMICOLON       reduce using rule 96 (assign -> lhs SETEQUAL expression .)
    RPAREN          reduce using rule 96 (assign -> lhs SETEQUAL expression .)
    COMMA           reduce using rule 96 (assign -> lhs SETEQUAL expression .)
    PLUS            shift and go to state 159
    MINUS           shift and go to state 160
    TIMES           shift and go to state 161
    DIVIDE          shift and go to state 162
    GREATER         shift and go to state 163
    LESS            shift and go to state 164
    GREATEREQ       shift and go to state 165
    LESSEQ          shift and go to state 166
    EQUAL           shift and go to state 167
    NOTEQUAL        shift and go to state 168
    AND             shift and go to state 169
    OR              shift and go to state 170

  ! PLUS            [ reduce using rule 96 (assign -> lhs SETEQUAL expression .) ]
  ! MINUS           [ reduce using rule 96 (assign -> lhs SETEQUAL expression .) ]
  ! TIMES           [ reduce using rule 96 (assign -> lhs SETEQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 96 (assign -> lhs SETEQUAL expression .) ]
  ! GREATER         [ reduce using rule 96 (assign -> lhs SETEQUAL expression .) ]
  ! LESS            [ reduce using rule 96 (assign -> lhs SETEQUAL expression .) ]
  ! GREATEREQ       [ reduce using rule 96 (assign -> lhs SETEQUAL expression .) ]
  ! LESSEQ          [ reduce using rule 96 (assign -> lhs SETEQUAL expression .) ]
  ! EQUAL           [ reduce using rule 96 (assign -> lhs SETEQUAL expression .) ]
  ! NOTEQUAL        [ reduce using rule 96 (assign -> lhs SETEQUAL expression .) ]
  ! AND             [ reduce using rule 96 (assign -> lhs SETEQUAL expression .) ]
  ! OR              [ reduce using rule 96 (assign -> lhs SETEQUAL expression .) ]

    arith_op                       shift and go to state 157
    bool_op                        shift and go to state 158

state 177

    (87) method_invocation -> field_access LPAREN arguments . RPAREN

    RPAREN          shift and go to state 191


state 178

    (88) method_invocation -> field_access LPAREN RPAREN .

    SEMICOLON       reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    DOT             reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    RPAREN          reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    PLUS            reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    MINUS           reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    TIMES           reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    DIVIDE          reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    GREATER         reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    LESS            reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    GREATEREQ       reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    LESSEQ          reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    EQUAL           reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    AND             reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    OR              reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)
    COMMA           reduce using rule 88 (method_invocation -> field_access LPAREN RPAREN .)


state 179

    (82) arguments -> expression .
    (83) arguments -> expression . COMMA arguments
    (91) expression -> expression . arith_op expression
    (92) expression -> expression . bool_op expression
    (101) arith_op -> . PLUS
    (102) arith_op -> . MINUS
    (103) arith_op -> . TIMES
    (104) arith_op -> . DIVIDE
    (105) bool_op -> . GREATER
    (106) bool_op -> . LESS
    (107) bool_op -> . GREATEREQ
    (108) bool_op -> . LESSEQ
    (109) bool_op -> . EQUAL
    (110) bool_op -> . NOTEQUAL
    (111) bool_op -> . AND
    (112) bool_op -> . OR

    RPAREN          reduce using rule 82 (arguments -> expression .)
    COMMA           shift and go to state 192
    PLUS            shift and go to state 159
    MINUS           shift and go to state 160
    TIMES           shift and go to state 161
    DIVIDE          shift and go to state 162
    GREATER         shift and go to state 163
    LESS            shift and go to state 164
    GREATEREQ       shift and go to state 165
    LESSEQ          shift and go to state 166
    EQUAL           shift and go to state 167
    NOTEQUAL        shift and go to state 168
    AND             shift and go to state 169
    OR              shift and go to state 170

    arith_op                       shift and go to state 157
    bool_op                        shift and go to state 158

state 180

    (85) field_access -> primary DOT ID .

    LPAREN          reduce using rule 85 (field_access -> primary DOT ID .)
    SETEQUAL        reduce using rule 85 (field_access -> primary DOT ID .)
    PLUSPLUS        reduce using rule 85 (field_access -> primary DOT ID .)
    MINUSMINUS      reduce using rule 85 (field_access -> primary DOT ID .)
    DOT             reduce using rule 85 (field_access -> primary DOT ID .)
    RPAREN          reduce using rule 85 (field_access -> primary DOT ID .)
    PLUS            reduce using rule 85 (field_access -> primary DOT ID .)
    MINUS           reduce using rule 85 (field_access -> primary DOT ID .)
    TIMES           reduce using rule 85 (field_access -> primary DOT ID .)
    DIVIDE          reduce using rule 85 (field_access -> primary DOT ID .)
    GREATER         reduce using rule 85 (field_access -> primary DOT ID .)
    LESS            reduce using rule 85 (field_access -> primary DOT ID .)
    GREATEREQ       reduce using rule 85 (field_access -> primary DOT ID .)
    LESSEQ          reduce using rule 85 (field_access -> primary DOT ID .)
    EQUAL           reduce using rule 85 (field_access -> primary DOT ID .)
    NOTEQUAL        reduce using rule 85 (field_access -> primary DOT ID .)
    AND             reduce using rule 85 (field_access -> primary DOT ID .)
    OR              reduce using rule 85 (field_access -> primary DOT ID .)
    SEMICOLON       reduce using rule 85 (field_access -> primary DOT ID .)
    COMMA           reduce using rule 85 (field_access -> primary DOT ID .)


state 181

    (78) primary -> NEW ID LPAREN . RPAREN
    (79) primary -> NEW ID LPAREN . arguments RPAREN
    (82) arguments -> . expression
    (83) arguments -> . expression COMMA arguments
    (89) expression -> . primary
    (90) expression -> . assign
    (91) expression -> . expression arith_op expression
    (92) expression -> . expression bool_op expression
    (93) expression -> . unary_op expression
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (113) unary_op -> . PLUS
    (114) unary_op -> . MINUS
    (115) unary_op -> . NOT
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID

    RPAREN          shift and go to state 193
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    NOT             shift and go to state 130
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105
    ID              shift and go to state 125

    arguments                      shift and go to state 194
    expression                     shift and go to state 179
    primary                        shift and go to state 122
    assign                         shift and go to state 123
    unary_op                       shift and go to state 124
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126
    lhs                            shift and go to state 127
    field_access                   shift and go to state 93

state 182

    (31) method_decl -> modifier type ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 31 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    ID              reduce using rule 31 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 31 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 31 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 31 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 31 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    INT             reduce using rule 31 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 31 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 31 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    STRING          reduce using rule 31 (method_decl -> modifier type ID LPAREN formals RPAREN block .)


state 183

    (33) method_decl -> modifier VOID ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 33 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    ID              reduce using rule 33 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 33 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 33 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 33 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 33 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    INT             reduce using rule 33 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 33 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 33 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    STRING          reduce using rule 33 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)


state 184

    (49) stmt -> IF LPAREN expression RPAREN . stmt
    (50) stmt -> IF LPAREN expression RPAREN . stmt ELSE stmt
    (49) stmt -> . IF LPAREN expression RPAREN stmt
    (50) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (51) stmt -> . WHILE LPAREN expression RPAREN stmt
    (52) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (60) stmt -> . RETURN expression SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . stmt_expression SEMICOLON
    (63) stmt -> . BREAK SEMICOLON
    (64) stmt -> . CONTINUE SEMICOLON
    (65) stmt -> . block
    (66) stmt -> . var_decl
    (67) stmt -> . SEMICOLON
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (21) var_decl -> . type variables SEMICOLON
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (118) empty -> .
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for PLUSPLUS resolved as shift
  ! shift/reduce conflict for MINUSMINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 76
    WHILE           shift and go to state 78
    FOR             shift and go to state 79
    RETURN          shift and go to state 82
    BREAK           shift and go to state 83
    CONTINUE        shift and go to state 84
    SEMICOLON       shift and go to state 81
    LCURLY          shift and go to state 58
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ELSE            reduce using rule 118 (empty -> .)
    RCURLY          reduce using rule 118 (empty -> .)
    INT             shift and go to state 23
    FLOAT           shift and go to state 94
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 95
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

  ! IF              [ reduce using rule 118 (empty -> .) ]
  ! WHILE           [ reduce using rule 118 (empty -> .) ]
  ! FOR             [ reduce using rule 118 (empty -> .) ]
  ! RETURN          [ reduce using rule 118 (empty -> .) ]
  ! BREAK           [ reduce using rule 118 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 118 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 118 (empty -> .) ]
  ! LCURLY          [ reduce using rule 118 (empty -> .) ]
  ! PLUSPLUS        [ reduce using rule 118 (empty -> .) ]
  ! MINUSMINUS      [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]
  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! THIS            [ reduce using rule 118 (empty -> .) ]
  ! SUPER           [ reduce using rule 118 (empty -> .) ]
  ! LPAREN          [ reduce using rule 118 (empty -> .) ]
  ! NEW             [ reduce using rule 118 (empty -> .) ]
  ! INTEGER         [ reduce using rule 118 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 118 (empty -> .) ]
  ! NULL            [ reduce using rule 118 (empty -> .) ]
  ! FALSE           [ reduce using rule 118 (empty -> .) ]
  ! TRUE            [ reduce using rule 118 (empty -> .) ]

    stmt                           shift and go to state 195
    stmt_expression                shift and go to state 80
    block                          shift and go to state 85
    var_decl                       shift and go to state 86
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    empty                          shift and go to state 59
    type                           shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 185

    (91) expression -> expression arith_op expression .
    (91) expression -> expression . arith_op expression
    (92) expression -> expression . bool_op expression
    (101) arith_op -> . PLUS
    (102) arith_op -> . MINUS
    (103) arith_op -> . TIMES
    (104) arith_op -> . DIVIDE
    (105) bool_op -> . GREATER
    (106) bool_op -> . LESS
    (107) bool_op -> . GREATEREQ
    (108) bool_op -> . LESSEQ
    (109) bool_op -> . EQUAL
    (110) bool_op -> . NOTEQUAL
    (111) bool_op -> . AND
    (112) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 91 (expression -> expression arith_op expression .)
    SEMICOLON       reduce using rule 91 (expression -> expression arith_op expression .)
    COMMA           reduce using rule 91 (expression -> expression arith_op expression .)
    PLUS            shift and go to state 159
    MINUS           shift and go to state 160
    TIMES           shift and go to state 161
    DIVIDE          shift and go to state 162
    GREATER         shift and go to state 163
    LESS            shift and go to state 164
    GREATEREQ       shift and go to state 165
    LESSEQ          shift and go to state 166
    EQUAL           shift and go to state 167
    NOTEQUAL        shift and go to state 168
    AND             shift and go to state 169
    OR              shift and go to state 170

  ! PLUS            [ reduce using rule 91 (expression -> expression arith_op expression .) ]
  ! MINUS           [ reduce using rule 91 (expression -> expression arith_op expression .) ]
  ! TIMES           [ reduce using rule 91 (expression -> expression arith_op expression .) ]
  ! DIVIDE          [ reduce using rule 91 (expression -> expression arith_op expression .) ]
  ! GREATER         [ reduce using rule 91 (expression -> expression arith_op expression .) ]
  ! LESS            [ reduce using rule 91 (expression -> expression arith_op expression .) ]
  ! GREATEREQ       [ reduce using rule 91 (expression -> expression arith_op expression .) ]
  ! LESSEQ          [ reduce using rule 91 (expression -> expression arith_op expression .) ]
  ! EQUAL           [ reduce using rule 91 (expression -> expression arith_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 91 (expression -> expression arith_op expression .) ]
  ! AND             [ reduce using rule 91 (expression -> expression arith_op expression .) ]
  ! OR              [ reduce using rule 91 (expression -> expression arith_op expression .) ]

    arith_op                       shift and go to state 157
    bool_op                        shift and go to state 158

state 186

    (92) expression -> expression bool_op expression .
    (91) expression -> expression . arith_op expression
    (92) expression -> expression . bool_op expression
    (101) arith_op -> . PLUS
    (102) arith_op -> . MINUS
    (103) arith_op -> . TIMES
    (104) arith_op -> . DIVIDE
    (105) bool_op -> . GREATER
    (106) bool_op -> . LESS
    (107) bool_op -> . GREATEREQ
    (108) bool_op -> . LESSEQ
    (109) bool_op -> . EQUAL
    (110) bool_op -> . NOTEQUAL
    (111) bool_op -> . AND
    (112) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 92 (expression -> expression bool_op expression .)
    SEMICOLON       reduce using rule 92 (expression -> expression bool_op expression .)
    COMMA           reduce using rule 92 (expression -> expression bool_op expression .)
    PLUS            shift and go to state 159
    MINUS           shift and go to state 160
    TIMES           shift and go to state 161
    DIVIDE          shift and go to state 162
    GREATER         shift and go to state 163
    LESS            shift and go to state 164
    GREATEREQ       shift and go to state 165
    LESSEQ          shift and go to state 166
    EQUAL           shift and go to state 167
    NOTEQUAL        shift and go to state 168
    AND             shift and go to state 169
    OR              shift and go to state 170

  ! PLUS            [ reduce using rule 92 (expression -> expression bool_op expression .) ]
  ! MINUS           [ reduce using rule 92 (expression -> expression bool_op expression .) ]
  ! TIMES           [ reduce using rule 92 (expression -> expression bool_op expression .) ]
  ! DIVIDE          [ reduce using rule 92 (expression -> expression bool_op expression .) ]
  ! GREATER         [ reduce using rule 92 (expression -> expression bool_op expression .) ]
  ! LESS            [ reduce using rule 92 (expression -> expression bool_op expression .) ]
  ! GREATEREQ       [ reduce using rule 92 (expression -> expression bool_op expression .) ]
  ! LESSEQ          [ reduce using rule 92 (expression -> expression bool_op expression .) ]
  ! EQUAL           [ reduce using rule 92 (expression -> expression bool_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 92 (expression -> expression bool_op expression .) ]
  ! AND             [ reduce using rule 92 (expression -> expression bool_op expression .) ]
  ! OR              [ reduce using rule 92 (expression -> expression bool_op expression .) ]

    bool_op                        shift and go to state 158
    arith_op                       shift and go to state 157

state 187

    (51) stmt -> WHILE LPAREN expression RPAREN . stmt
    (49) stmt -> . IF LPAREN expression RPAREN stmt
    (50) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (51) stmt -> . WHILE LPAREN expression RPAREN stmt
    (52) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (60) stmt -> . RETURN expression SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . stmt_expression SEMICOLON
    (63) stmt -> . BREAK SEMICOLON
    (64) stmt -> . CONTINUE SEMICOLON
    (65) stmt -> . block
    (66) stmt -> . var_decl
    (67) stmt -> . SEMICOLON
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (21) var_decl -> . type variables SEMICOLON
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (118) empty -> .
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for PLUSPLUS resolved as shift
  ! shift/reduce conflict for MINUSMINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 76
    WHILE           shift and go to state 78
    FOR             shift and go to state 79
    RETURN          shift and go to state 82
    BREAK           shift and go to state 83
    CONTINUE        shift and go to state 84
    SEMICOLON       shift and go to state 81
    LCURLY          shift and go to state 58
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ELSE            reduce using rule 118 (empty -> .)
    RCURLY          reduce using rule 118 (empty -> .)
    INT             shift and go to state 23
    FLOAT           shift and go to state 94
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 95
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

  ! IF              [ reduce using rule 118 (empty -> .) ]
  ! WHILE           [ reduce using rule 118 (empty -> .) ]
  ! FOR             [ reduce using rule 118 (empty -> .) ]
  ! RETURN          [ reduce using rule 118 (empty -> .) ]
  ! BREAK           [ reduce using rule 118 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 118 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 118 (empty -> .) ]
  ! LCURLY          [ reduce using rule 118 (empty -> .) ]
  ! PLUSPLUS        [ reduce using rule 118 (empty -> .) ]
  ! MINUSMINUS      [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]
  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! THIS            [ reduce using rule 118 (empty -> .) ]
  ! SUPER           [ reduce using rule 118 (empty -> .) ]
  ! LPAREN          [ reduce using rule 118 (empty -> .) ]
  ! NEW             [ reduce using rule 118 (empty -> .) ]
  ! INTEGER         [ reduce using rule 118 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 118 (empty -> .) ]
  ! NULL            [ reduce using rule 118 (empty -> .) ]
  ! FALSE           [ reduce using rule 118 (empty -> .) ]
  ! TRUE            [ reduce using rule 118 (empty -> .) ]

    stmt                           shift and go to state 196
    stmt_expression                shift and go to state 80
    block                          shift and go to state 85
    var_decl                       shift and go to state 86
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    empty                          shift and go to state 59
    type                           shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 188

    (52) stmt -> FOR LPAREN stmt_expression SEMICOLON . expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> FOR LPAREN stmt_expression SEMICOLON . expression SEMICOLON RPAREN stmt
    (54) stmt -> FOR LPAREN stmt_expression SEMICOLON . SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> FOR LPAREN stmt_expression SEMICOLON . SEMICOLON RPAREN stmt
    (89) expression -> . primary
    (90) expression -> . assign
    (91) expression -> . expression arith_op expression
    (92) expression -> . expression bool_op expression
    (93) expression -> . unary_op expression
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (113) unary_op -> . PLUS
    (114) unary_op -> . MINUS
    (115) unary_op -> . NOT
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID

    SEMICOLON       shift and go to state 197
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    NOT             shift and go to state 130
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105
    ID              shift and go to state 125

    expression                     shift and go to state 198
    primary                        shift and go to state 122
    assign                         shift and go to state 123
    unary_op                       shift and go to state 124
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126
    lhs                            shift and go to state 127
    field_access                   shift and go to state 93

state 189

    (57) stmt -> FOR LPAREN SEMICOLON SEMICOLON . stmt_expression RPAREN stmt
    (59) stmt -> FOR LPAREN SEMICOLON SEMICOLON . RPAREN stmt
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

    RPAREN          shift and go to state 200
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ID              shift and go to state 125
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

    stmt_expression                shift and go to state 199
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 190

    (55) stmt -> FOR LPAREN SEMICOLON expression . SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> FOR LPAREN SEMICOLON expression . SEMICOLON RPAREN stmt
    (91) expression -> expression . arith_op expression
    (92) expression -> expression . bool_op expression
    (101) arith_op -> . PLUS
    (102) arith_op -> . MINUS
    (103) arith_op -> . TIMES
    (104) arith_op -> . DIVIDE
    (105) bool_op -> . GREATER
    (106) bool_op -> . LESS
    (107) bool_op -> . GREATEREQ
    (108) bool_op -> . LESSEQ
    (109) bool_op -> . EQUAL
    (110) bool_op -> . NOTEQUAL
    (111) bool_op -> . AND
    (112) bool_op -> . OR

    SEMICOLON       shift and go to state 201
    PLUS            shift and go to state 159
    MINUS           shift and go to state 160
    TIMES           shift and go to state 161
    DIVIDE          shift and go to state 162
    GREATER         shift and go to state 163
    LESS            shift and go to state 164
    GREATEREQ       shift and go to state 165
    LESSEQ          shift and go to state 166
    EQUAL           shift and go to state 167
    NOTEQUAL        shift and go to state 168
    AND             shift and go to state 169
    OR              shift and go to state 170

    arith_op                       shift and go to state 157
    bool_op                        shift and go to state 158

state 191

    (87) method_invocation -> field_access LPAREN arguments RPAREN .

    SEMICOLON       reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DOT             reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    PLUS            reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    MINUS           reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    TIMES           reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATER         reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESS            reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATEREQ       reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESSEQ          reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    NOTEQUAL        reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    AND             reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    OR              reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)
    COMMA           reduce using rule 87 (method_invocation -> field_access LPAREN arguments RPAREN .)


state 192

    (83) arguments -> expression COMMA . arguments
    (82) arguments -> . expression
    (83) arguments -> . expression COMMA arguments
    (89) expression -> . primary
    (90) expression -> . assign
    (91) expression -> . expression arith_op expression
    (92) expression -> . expression bool_op expression
    (93) expression -> . unary_op expression
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (113) unary_op -> . PLUS
    (114) unary_op -> . MINUS
    (115) unary_op -> . NOT
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID

    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    NOT             shift and go to state 130
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105
    ID              shift and go to state 125

    expression                     shift and go to state 179
    arguments                      shift and go to state 202
    primary                        shift and go to state 122
    assign                         shift and go to state 123
    unary_op                       shift and go to state 124
    literal                        shift and go to state 97
    method_invocation              shift and go to state 126
    lhs                            shift and go to state 127
    field_access                   shift and go to state 93

state 193

    (78) primary -> NEW ID LPAREN RPAREN .

    DOT             reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    RPAREN          reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    PLUS            reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    MINUS           reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    TIMES           reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    GREATER         reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    LESS            reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    GREATEREQ       reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    LESSEQ          reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    EQUAL           reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    AND             reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    OR              reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)
    COMMA           reduce using rule 78 (primary -> NEW ID LPAREN RPAREN .)


state 194

    (79) primary -> NEW ID LPAREN arguments . RPAREN

    RPAREN          shift and go to state 203


state 195

    (49) stmt -> IF LPAREN expression RPAREN stmt .
    (50) stmt -> IF LPAREN expression RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    RCURLY          reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    IF              reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    WHILE           reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    FOR             reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    RETURN          reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    BREAK           reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    CONTINUE        reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    SEMICOLON       reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    LCURLY          reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    PLUSPLUS        reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    MINUSMINUS      reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    INT             reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    FLOAT           reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    BOOLEAN         reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    STRING          reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    ID              reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    THIS            reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    SUPER           reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    LPAREN          reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    NEW             reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    INTEGER         reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    STRING_LITERAL  reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    NULL            reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    FALSE           reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    TRUE            reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .)
    ELSE            shift and go to state 204

  ! ELSE            [ reduce using rule 49 (stmt -> IF LPAREN expression RPAREN stmt .) ]


state 196

    (51) stmt -> WHILE LPAREN expression RPAREN stmt .

    RCURLY          reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    IF              reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    WHILE           reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    FOR             reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    RETURN          reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    BREAK           reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    CONTINUE        reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    SEMICOLON       reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    LCURLY          reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    PLUSPLUS        reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    MINUSMINUS      reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    INT             reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    FLOAT           reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    BOOLEAN         reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    STRING          reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    ID              reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    THIS            reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    SUPER           reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    LPAREN          reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    NEW             reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    INTEGER         reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    STRING_LITERAL  reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    NULL            reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    FALSE           reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    TRUE            reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    ELSE            reduce using rule 51 (stmt -> WHILE LPAREN expression RPAREN stmt .)


state 197

    (54) stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON . stmt_expression RPAREN stmt
    (56) stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON . RPAREN stmt
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

    RPAREN          shift and go to state 206
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ID              shift and go to state 125
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

    stmt_expression                shift and go to state 205
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 198

    (52) stmt -> FOR LPAREN stmt_expression SEMICOLON expression . SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> FOR LPAREN stmt_expression SEMICOLON expression . SEMICOLON RPAREN stmt
    (91) expression -> expression . arith_op expression
    (92) expression -> expression . bool_op expression
    (101) arith_op -> . PLUS
    (102) arith_op -> . MINUS
    (103) arith_op -> . TIMES
    (104) arith_op -> . DIVIDE
    (105) bool_op -> . GREATER
    (106) bool_op -> . LESS
    (107) bool_op -> . GREATEREQ
    (108) bool_op -> . LESSEQ
    (109) bool_op -> . EQUAL
    (110) bool_op -> . NOTEQUAL
    (111) bool_op -> . AND
    (112) bool_op -> . OR

    SEMICOLON       shift and go to state 207
    PLUS            shift and go to state 159
    MINUS           shift and go to state 160
    TIMES           shift and go to state 161
    DIVIDE          shift and go to state 162
    GREATER         shift and go to state 163
    LESS            shift and go to state 164
    GREATEREQ       shift and go to state 165
    LESSEQ          shift and go to state 166
    EQUAL           shift and go to state 167
    NOTEQUAL        shift and go to state 168
    AND             shift and go to state 169
    OR              shift and go to state 170

    arith_op                       shift and go to state 157
    bool_op                        shift and go to state 158

state 199

    (57) stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression . RPAREN stmt

    RPAREN          shift and go to state 208


state 200

    (59) stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN . stmt
    (49) stmt -> . IF LPAREN expression RPAREN stmt
    (50) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (51) stmt -> . WHILE LPAREN expression RPAREN stmt
    (52) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (60) stmt -> . RETURN expression SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . stmt_expression SEMICOLON
    (63) stmt -> . BREAK SEMICOLON
    (64) stmt -> . CONTINUE SEMICOLON
    (65) stmt -> . block
    (66) stmt -> . var_decl
    (67) stmt -> . SEMICOLON
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (21) var_decl -> . type variables SEMICOLON
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (118) empty -> .
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for PLUSPLUS resolved as shift
  ! shift/reduce conflict for MINUSMINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 76
    WHILE           shift and go to state 78
    FOR             shift and go to state 79
    RETURN          shift and go to state 82
    BREAK           shift and go to state 83
    CONTINUE        shift and go to state 84
    SEMICOLON       shift and go to state 81
    LCURLY          shift and go to state 58
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ELSE            reduce using rule 118 (empty -> .)
    RCURLY          reduce using rule 118 (empty -> .)
    INT             shift and go to state 23
    FLOAT           shift and go to state 94
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 95
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

  ! IF              [ reduce using rule 118 (empty -> .) ]
  ! WHILE           [ reduce using rule 118 (empty -> .) ]
  ! FOR             [ reduce using rule 118 (empty -> .) ]
  ! RETURN          [ reduce using rule 118 (empty -> .) ]
  ! BREAK           [ reduce using rule 118 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 118 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 118 (empty -> .) ]
  ! LCURLY          [ reduce using rule 118 (empty -> .) ]
  ! PLUSPLUS        [ reduce using rule 118 (empty -> .) ]
  ! MINUSMINUS      [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]
  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! THIS            [ reduce using rule 118 (empty -> .) ]
  ! SUPER           [ reduce using rule 118 (empty -> .) ]
  ! LPAREN          [ reduce using rule 118 (empty -> .) ]
  ! NEW             [ reduce using rule 118 (empty -> .) ]
  ! INTEGER         [ reduce using rule 118 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 118 (empty -> .) ]
  ! NULL            [ reduce using rule 118 (empty -> .) ]
  ! FALSE           [ reduce using rule 118 (empty -> .) ]
  ! TRUE            [ reduce using rule 118 (empty -> .) ]

    stmt                           shift and go to state 209
    stmt_expression                shift and go to state 80
    block                          shift and go to state 85
    var_decl                       shift and go to state 86
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    empty                          shift and go to state 59
    type                           shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 201

    (55) stmt -> FOR LPAREN SEMICOLON expression SEMICOLON . stmt_expression RPAREN stmt
    (58) stmt -> FOR LPAREN SEMICOLON expression SEMICOLON . RPAREN stmt
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

    RPAREN          shift and go to state 211
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ID              shift and go to state 125
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

    stmt_expression                shift and go to state 210
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 202

    (83) arguments -> expression COMMA arguments .

    RPAREN          reduce using rule 83 (arguments -> expression COMMA arguments .)


state 203

    (79) primary -> NEW ID LPAREN arguments RPAREN .

    DOT             reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    PLUS            reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    MINUS           reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    TIMES           reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    GREATER         reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    LESS            reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    GREATEREQ       reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    LESSEQ          reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    NOTEQUAL        reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    AND             reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    OR              reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)
    COMMA           reduce using rule 79 (primary -> NEW ID LPAREN arguments RPAREN .)


state 204

    (50) stmt -> IF LPAREN expression RPAREN stmt ELSE . stmt
    (49) stmt -> . IF LPAREN expression RPAREN stmt
    (50) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (51) stmt -> . WHILE LPAREN expression RPAREN stmt
    (52) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (60) stmt -> . RETURN expression SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . stmt_expression SEMICOLON
    (63) stmt -> . BREAK SEMICOLON
    (64) stmt -> . CONTINUE SEMICOLON
    (65) stmt -> . block
    (66) stmt -> . var_decl
    (67) stmt -> . SEMICOLON
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (21) var_decl -> . type variables SEMICOLON
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (118) empty -> .
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for PLUSPLUS resolved as shift
  ! shift/reduce conflict for MINUSMINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 76
    WHILE           shift and go to state 78
    FOR             shift and go to state 79
    RETURN          shift and go to state 82
    BREAK           shift and go to state 83
    CONTINUE        shift and go to state 84
    SEMICOLON       shift and go to state 81
    LCURLY          shift and go to state 58
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ELSE            reduce using rule 118 (empty -> .)
    RCURLY          reduce using rule 118 (empty -> .)
    INT             shift and go to state 23
    FLOAT           shift and go to state 94
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 95
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

  ! IF              [ reduce using rule 118 (empty -> .) ]
  ! WHILE           [ reduce using rule 118 (empty -> .) ]
  ! FOR             [ reduce using rule 118 (empty -> .) ]
  ! RETURN          [ reduce using rule 118 (empty -> .) ]
  ! BREAK           [ reduce using rule 118 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 118 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 118 (empty -> .) ]
  ! LCURLY          [ reduce using rule 118 (empty -> .) ]
  ! PLUSPLUS        [ reduce using rule 118 (empty -> .) ]
  ! MINUSMINUS      [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]
  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! THIS            [ reduce using rule 118 (empty -> .) ]
  ! SUPER           [ reduce using rule 118 (empty -> .) ]
  ! LPAREN          [ reduce using rule 118 (empty -> .) ]
  ! NEW             [ reduce using rule 118 (empty -> .) ]
  ! INTEGER         [ reduce using rule 118 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 118 (empty -> .) ]
  ! NULL            [ reduce using rule 118 (empty -> .) ]
  ! FALSE           [ reduce using rule 118 (empty -> .) ]
  ! TRUE            [ reduce using rule 118 (empty -> .) ]

    stmt                           shift and go to state 212
    stmt_expression                shift and go to state 80
    block                          shift and go to state 85
    var_decl                       shift and go to state 86
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    empty                          shift and go to state 59
    type                           shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 205

    (54) stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression . RPAREN stmt

    RPAREN          shift and go to state 213


state 206

    (56) stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN . stmt
    (49) stmt -> . IF LPAREN expression RPAREN stmt
    (50) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (51) stmt -> . WHILE LPAREN expression RPAREN stmt
    (52) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (60) stmt -> . RETURN expression SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . stmt_expression SEMICOLON
    (63) stmt -> . BREAK SEMICOLON
    (64) stmt -> . CONTINUE SEMICOLON
    (65) stmt -> . block
    (66) stmt -> . var_decl
    (67) stmt -> . SEMICOLON
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (21) var_decl -> . type variables SEMICOLON
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (118) empty -> .
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for PLUSPLUS resolved as shift
  ! shift/reduce conflict for MINUSMINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 76
    WHILE           shift and go to state 78
    FOR             shift and go to state 79
    RETURN          shift and go to state 82
    BREAK           shift and go to state 83
    CONTINUE        shift and go to state 84
    SEMICOLON       shift and go to state 81
    LCURLY          shift and go to state 58
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ELSE            reduce using rule 118 (empty -> .)
    RCURLY          reduce using rule 118 (empty -> .)
    INT             shift and go to state 23
    FLOAT           shift and go to state 94
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 95
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

  ! IF              [ reduce using rule 118 (empty -> .) ]
  ! WHILE           [ reduce using rule 118 (empty -> .) ]
  ! FOR             [ reduce using rule 118 (empty -> .) ]
  ! RETURN          [ reduce using rule 118 (empty -> .) ]
  ! BREAK           [ reduce using rule 118 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 118 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 118 (empty -> .) ]
  ! LCURLY          [ reduce using rule 118 (empty -> .) ]
  ! PLUSPLUS        [ reduce using rule 118 (empty -> .) ]
  ! MINUSMINUS      [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]
  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! THIS            [ reduce using rule 118 (empty -> .) ]
  ! SUPER           [ reduce using rule 118 (empty -> .) ]
  ! LPAREN          [ reduce using rule 118 (empty -> .) ]
  ! NEW             [ reduce using rule 118 (empty -> .) ]
  ! INTEGER         [ reduce using rule 118 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 118 (empty -> .) ]
  ! NULL            [ reduce using rule 118 (empty -> .) ]
  ! FALSE           [ reduce using rule 118 (empty -> .) ]
  ! TRUE            [ reduce using rule 118 (empty -> .) ]

    stmt_expression                shift and go to state 80
    stmt                           shift and go to state 214
    block                          shift and go to state 85
    var_decl                       shift and go to state 86
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    empty                          shift and go to state 59
    type                           shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 207

    (52) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON . stmt_expression RPAREN stmt
    (53) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON . RPAREN stmt
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

    RPAREN          shift and go to state 216
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ID              shift and go to state 125
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    FLOAT           shift and go to state 131
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

    stmt_expression                shift and go to state 215
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 208

    (57) stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN . stmt
    (49) stmt -> . IF LPAREN expression RPAREN stmt
    (50) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (51) stmt -> . WHILE LPAREN expression RPAREN stmt
    (52) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (60) stmt -> . RETURN expression SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . stmt_expression SEMICOLON
    (63) stmt -> . BREAK SEMICOLON
    (64) stmt -> . CONTINUE SEMICOLON
    (65) stmt -> . block
    (66) stmt -> . var_decl
    (67) stmt -> . SEMICOLON
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (21) var_decl -> . type variables SEMICOLON
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (118) empty -> .
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for PLUSPLUS resolved as shift
  ! shift/reduce conflict for MINUSMINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 76
    WHILE           shift and go to state 78
    FOR             shift and go to state 79
    RETURN          shift and go to state 82
    BREAK           shift and go to state 83
    CONTINUE        shift and go to state 84
    SEMICOLON       shift and go to state 81
    LCURLY          shift and go to state 58
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ELSE            reduce using rule 118 (empty -> .)
    RCURLY          reduce using rule 118 (empty -> .)
    INT             shift and go to state 23
    FLOAT           shift and go to state 94
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 95
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

  ! IF              [ reduce using rule 118 (empty -> .) ]
  ! WHILE           [ reduce using rule 118 (empty -> .) ]
  ! FOR             [ reduce using rule 118 (empty -> .) ]
  ! RETURN          [ reduce using rule 118 (empty -> .) ]
  ! BREAK           [ reduce using rule 118 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 118 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 118 (empty -> .) ]
  ! LCURLY          [ reduce using rule 118 (empty -> .) ]
  ! PLUSPLUS        [ reduce using rule 118 (empty -> .) ]
  ! MINUSMINUS      [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]
  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! THIS            [ reduce using rule 118 (empty -> .) ]
  ! SUPER           [ reduce using rule 118 (empty -> .) ]
  ! LPAREN          [ reduce using rule 118 (empty -> .) ]
  ! NEW             [ reduce using rule 118 (empty -> .) ]
  ! INTEGER         [ reduce using rule 118 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 118 (empty -> .) ]
  ! NULL            [ reduce using rule 118 (empty -> .) ]
  ! FALSE           [ reduce using rule 118 (empty -> .) ]
  ! TRUE            [ reduce using rule 118 (empty -> .) ]

    stmt_expression                shift and go to state 80
    stmt                           shift and go to state 217
    block                          shift and go to state 85
    var_decl                       shift and go to state 86
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    empty                          shift and go to state 59
    type                           shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 209

    (59) stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .

    RCURLY          reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    IF              reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    WHILE           reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    FOR             reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    RETURN          reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    BREAK           reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    CONTINUE        reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    SEMICOLON       reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    LCURLY          reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    PLUSPLUS        reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    MINUSMINUS      reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    INT             reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    FLOAT           reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    BOOLEAN         reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    STRING          reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    ID              reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    THIS            reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    SUPER           reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    LPAREN          reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    NEW             reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    INTEGER         reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    STRING_LITERAL  reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    NULL            reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    FALSE           reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    TRUE            reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)
    ELSE            reduce using rule 59 (stmt -> FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt .)


state 210

    (55) stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression . RPAREN stmt

    RPAREN          shift and go to state 218


state 211

    (58) stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN . stmt
    (49) stmt -> . IF LPAREN expression RPAREN stmt
    (50) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (51) stmt -> . WHILE LPAREN expression RPAREN stmt
    (52) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (60) stmt -> . RETURN expression SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . stmt_expression SEMICOLON
    (63) stmt -> . BREAK SEMICOLON
    (64) stmt -> . CONTINUE SEMICOLON
    (65) stmt -> . block
    (66) stmt -> . var_decl
    (67) stmt -> . SEMICOLON
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (21) var_decl -> . type variables SEMICOLON
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (118) empty -> .
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for PLUSPLUS resolved as shift
  ! shift/reduce conflict for MINUSMINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 76
    WHILE           shift and go to state 78
    FOR             shift and go to state 79
    RETURN          shift and go to state 82
    BREAK           shift and go to state 83
    CONTINUE        shift and go to state 84
    SEMICOLON       shift and go to state 81
    LCURLY          shift and go to state 58
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ELSE            reduce using rule 118 (empty -> .)
    RCURLY          reduce using rule 118 (empty -> .)
    INT             shift and go to state 23
    FLOAT           shift and go to state 94
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 95
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

  ! IF              [ reduce using rule 118 (empty -> .) ]
  ! WHILE           [ reduce using rule 118 (empty -> .) ]
  ! FOR             [ reduce using rule 118 (empty -> .) ]
  ! RETURN          [ reduce using rule 118 (empty -> .) ]
  ! BREAK           [ reduce using rule 118 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 118 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 118 (empty -> .) ]
  ! LCURLY          [ reduce using rule 118 (empty -> .) ]
  ! PLUSPLUS        [ reduce using rule 118 (empty -> .) ]
  ! MINUSMINUS      [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]
  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! THIS            [ reduce using rule 118 (empty -> .) ]
  ! SUPER           [ reduce using rule 118 (empty -> .) ]
  ! LPAREN          [ reduce using rule 118 (empty -> .) ]
  ! NEW             [ reduce using rule 118 (empty -> .) ]
  ! INTEGER         [ reduce using rule 118 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 118 (empty -> .) ]
  ! NULL            [ reduce using rule 118 (empty -> .) ]
  ! FALSE           [ reduce using rule 118 (empty -> .) ]
  ! TRUE            [ reduce using rule 118 (empty -> .) ]

    stmt                           shift and go to state 219
    stmt_expression                shift and go to state 80
    block                          shift and go to state 85
    var_decl                       shift and go to state 86
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    empty                          shift and go to state 59
    type                           shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 212

    (50) stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .

    RCURLY          reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    IF              reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    BREAK           reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    CONTINUE        reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    SEMICOLON       reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    LCURLY          reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    PLUSPLUS        reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    MINUSMINUS      reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    INT             reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    FLOAT           reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    BOOLEAN         reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    STRING          reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    ID              reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    THIS            reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    SUPER           reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    LPAREN          reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    NEW             reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    INTEGER         reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    STRING_LITERAL  reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    NULL            reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    FALSE           reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    TRUE            reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 50 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)


state 213

    (54) stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN . stmt
    (49) stmt -> . IF LPAREN expression RPAREN stmt
    (50) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (51) stmt -> . WHILE LPAREN expression RPAREN stmt
    (52) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (60) stmt -> . RETURN expression SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . stmt_expression SEMICOLON
    (63) stmt -> . BREAK SEMICOLON
    (64) stmt -> . CONTINUE SEMICOLON
    (65) stmt -> . block
    (66) stmt -> . var_decl
    (67) stmt -> . SEMICOLON
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (21) var_decl -> . type variables SEMICOLON
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (118) empty -> .
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for PLUSPLUS resolved as shift
  ! shift/reduce conflict for MINUSMINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 76
    WHILE           shift and go to state 78
    FOR             shift and go to state 79
    RETURN          shift and go to state 82
    BREAK           shift and go to state 83
    CONTINUE        shift and go to state 84
    SEMICOLON       shift and go to state 81
    LCURLY          shift and go to state 58
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ELSE            reduce using rule 118 (empty -> .)
    RCURLY          reduce using rule 118 (empty -> .)
    INT             shift and go to state 23
    FLOAT           shift and go to state 94
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 95
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

  ! IF              [ reduce using rule 118 (empty -> .) ]
  ! WHILE           [ reduce using rule 118 (empty -> .) ]
  ! FOR             [ reduce using rule 118 (empty -> .) ]
  ! RETURN          [ reduce using rule 118 (empty -> .) ]
  ! BREAK           [ reduce using rule 118 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 118 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 118 (empty -> .) ]
  ! LCURLY          [ reduce using rule 118 (empty -> .) ]
  ! PLUSPLUS        [ reduce using rule 118 (empty -> .) ]
  ! MINUSMINUS      [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]
  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! THIS            [ reduce using rule 118 (empty -> .) ]
  ! SUPER           [ reduce using rule 118 (empty -> .) ]
  ! LPAREN          [ reduce using rule 118 (empty -> .) ]
  ! NEW             [ reduce using rule 118 (empty -> .) ]
  ! INTEGER         [ reduce using rule 118 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 118 (empty -> .) ]
  ! NULL            [ reduce using rule 118 (empty -> .) ]
  ! FALSE           [ reduce using rule 118 (empty -> .) ]
  ! TRUE            [ reduce using rule 118 (empty -> .) ]

    stmt_expression                shift and go to state 80
    stmt                           shift and go to state 220
    block                          shift and go to state 85
    var_decl                       shift and go to state 86
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    empty                          shift and go to state 59
    type                           shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 214

    (56) stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .

    RCURLY          reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    IF              reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    WHILE           reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    FOR             reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    RETURN          reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    BREAK           reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    CONTINUE        reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    SEMICOLON       reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    LCURLY          reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    PLUSPLUS        reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    MINUSMINUS      reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    INT             reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    FLOAT           reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    BOOLEAN         reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    STRING          reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    ID              reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    THIS            reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    SUPER           reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    LPAREN          reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    NEW             reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    INTEGER         reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    STRING_LITERAL  reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    NULL            reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    FALSE           reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    TRUE            reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)
    ELSE            reduce using rule 56 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt .)


state 215

    (52) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression . RPAREN stmt

    RPAREN          shift and go to state 221


state 216

    (53) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN . stmt
    (49) stmt -> . IF LPAREN expression RPAREN stmt
    (50) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (51) stmt -> . WHILE LPAREN expression RPAREN stmt
    (52) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (60) stmt -> . RETURN expression SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . stmt_expression SEMICOLON
    (63) stmt -> . BREAK SEMICOLON
    (64) stmt -> . CONTINUE SEMICOLON
    (65) stmt -> . block
    (66) stmt -> . var_decl
    (67) stmt -> . SEMICOLON
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (21) var_decl -> . type variables SEMICOLON
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (118) empty -> .
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for PLUSPLUS resolved as shift
  ! shift/reduce conflict for MINUSMINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 76
    WHILE           shift and go to state 78
    FOR             shift and go to state 79
    RETURN          shift and go to state 82
    BREAK           shift and go to state 83
    CONTINUE        shift and go to state 84
    SEMICOLON       shift and go to state 81
    LCURLY          shift and go to state 58
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ELSE            reduce using rule 118 (empty -> .)
    RCURLY          reduce using rule 118 (empty -> .)
    INT             shift and go to state 23
    FLOAT           shift and go to state 94
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 95
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

  ! IF              [ reduce using rule 118 (empty -> .) ]
  ! WHILE           [ reduce using rule 118 (empty -> .) ]
  ! FOR             [ reduce using rule 118 (empty -> .) ]
  ! RETURN          [ reduce using rule 118 (empty -> .) ]
  ! BREAK           [ reduce using rule 118 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 118 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 118 (empty -> .) ]
  ! LCURLY          [ reduce using rule 118 (empty -> .) ]
  ! PLUSPLUS        [ reduce using rule 118 (empty -> .) ]
  ! MINUSMINUS      [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]
  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! THIS            [ reduce using rule 118 (empty -> .) ]
  ! SUPER           [ reduce using rule 118 (empty -> .) ]
  ! LPAREN          [ reduce using rule 118 (empty -> .) ]
  ! NEW             [ reduce using rule 118 (empty -> .) ]
  ! INTEGER         [ reduce using rule 118 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 118 (empty -> .) ]
  ! NULL            [ reduce using rule 118 (empty -> .) ]
  ! FALSE           [ reduce using rule 118 (empty -> .) ]
  ! TRUE            [ reduce using rule 118 (empty -> .) ]

    stmt_expression                shift and go to state 80
    stmt                           shift and go to state 222
    block                          shift and go to state 85
    var_decl                       shift and go to state 86
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    empty                          shift and go to state 59
    type                           shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 217

    (57) stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .

    RCURLY          reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    IF              reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    WHILE           reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    FOR             reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    RETURN          reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    BREAK           reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    CONTINUE        reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    SEMICOLON       reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    LCURLY          reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    PLUSPLUS        reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    MINUSMINUS      reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    INT             reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    FLOAT           reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    BOOLEAN         reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    STRING          reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    ID              reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    THIS            reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    SUPER           reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    LPAREN          reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    NEW             reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    INTEGER         reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    STRING_LITERAL  reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    NULL            reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    FALSE           reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    TRUE            reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    ELSE            reduce using rule 57 (stmt -> FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)


state 218

    (55) stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN . stmt
    (49) stmt -> . IF LPAREN expression RPAREN stmt
    (50) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (51) stmt -> . WHILE LPAREN expression RPAREN stmt
    (52) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (60) stmt -> . RETURN expression SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . stmt_expression SEMICOLON
    (63) stmt -> . BREAK SEMICOLON
    (64) stmt -> . CONTINUE SEMICOLON
    (65) stmt -> . block
    (66) stmt -> . var_decl
    (67) stmt -> . SEMICOLON
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (21) var_decl -> . type variables SEMICOLON
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (118) empty -> .
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for PLUSPLUS resolved as shift
  ! shift/reduce conflict for MINUSMINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 76
    WHILE           shift and go to state 78
    FOR             shift and go to state 79
    RETURN          shift and go to state 82
    BREAK           shift and go to state 83
    CONTINUE        shift and go to state 84
    SEMICOLON       shift and go to state 81
    LCURLY          shift and go to state 58
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ELSE            reduce using rule 118 (empty -> .)
    RCURLY          reduce using rule 118 (empty -> .)
    INT             shift and go to state 23
    FLOAT           shift and go to state 94
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 95
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

  ! IF              [ reduce using rule 118 (empty -> .) ]
  ! WHILE           [ reduce using rule 118 (empty -> .) ]
  ! FOR             [ reduce using rule 118 (empty -> .) ]
  ! RETURN          [ reduce using rule 118 (empty -> .) ]
  ! BREAK           [ reduce using rule 118 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 118 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 118 (empty -> .) ]
  ! LCURLY          [ reduce using rule 118 (empty -> .) ]
  ! PLUSPLUS        [ reduce using rule 118 (empty -> .) ]
  ! MINUSMINUS      [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]
  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! THIS            [ reduce using rule 118 (empty -> .) ]
  ! SUPER           [ reduce using rule 118 (empty -> .) ]
  ! LPAREN          [ reduce using rule 118 (empty -> .) ]
  ! NEW             [ reduce using rule 118 (empty -> .) ]
  ! INTEGER         [ reduce using rule 118 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 118 (empty -> .) ]
  ! NULL            [ reduce using rule 118 (empty -> .) ]
  ! FALSE           [ reduce using rule 118 (empty -> .) ]
  ! TRUE            [ reduce using rule 118 (empty -> .) ]

    stmt_expression                shift and go to state 80
    stmt                           shift and go to state 223
    block                          shift and go to state 85
    var_decl                       shift and go to state 86
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    empty                          shift and go to state 59
    type                           shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 219

    (58) stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .

    RCURLY          reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    IF              reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    WHILE           reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    FOR             reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    RETURN          reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    BREAK           reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    CONTINUE        reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    SEMICOLON       reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    LCURLY          reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    PLUSPLUS        reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    MINUSMINUS      reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    INT             reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    FLOAT           reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    BOOLEAN         reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    STRING          reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    ID              reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    THIS            reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    SUPER           reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    LPAREN          reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    NEW             reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    INTEGER         reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    STRING_LITERAL  reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    NULL            reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    FALSE           reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    TRUE            reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)
    ELSE            reduce using rule 58 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt .)


state 220

    (54) stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .

    RCURLY          reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    IF              reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    WHILE           reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    FOR             reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    RETURN          reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    BREAK           reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    CONTINUE        reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    SEMICOLON       reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    LCURLY          reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    PLUSPLUS        reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    MINUSMINUS      reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    INT             reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    FLOAT           reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    BOOLEAN         reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    STRING          reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    ID              reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    THIS            reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    SUPER           reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    LPAREN          reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    NEW             reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    INTEGER         reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    STRING_LITERAL  reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    NULL            reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    FALSE           reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    TRUE            reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)
    ELSE            reduce using rule 54 (stmt -> FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt .)


state 221

    (52) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN . stmt
    (49) stmt -> . IF LPAREN expression RPAREN stmt
    (50) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (51) stmt -> . WHILE LPAREN expression RPAREN stmt
    (52) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (53) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt
    (54) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (55) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (56) stmt -> . FOR LPAREN stmt_expression SEMICOLON SEMICOLON RPAREN stmt
    (57) stmt -> . FOR LPAREN SEMICOLON SEMICOLON stmt_expression RPAREN stmt
    (58) stmt -> . FOR LPAREN SEMICOLON expression SEMICOLON RPAREN stmt
    (59) stmt -> . FOR LPAREN SEMICOLON SEMICOLON RPAREN stmt
    (60) stmt -> . RETURN expression SEMICOLON
    (61) stmt -> . RETURN SEMICOLON
    (62) stmt -> . stmt_expression SEMICOLON
    (63) stmt -> . BREAK SEMICOLON
    (64) stmt -> . CONTINUE SEMICOLON
    (65) stmt -> . block
    (66) stmt -> . var_decl
    (67) stmt -> . SEMICOLON
    (116) stmt_expression -> . assign
    (117) stmt_expression -> . method_invocation
    (45) block -> . LCURLY stmtlist RCURLY
    (46) block -> . empty
    (21) var_decl -> . type variables SEMICOLON
    (96) assign -> . lhs SETEQUAL expression
    (97) assign -> . lhs PLUSPLUS
    (98) assign -> . lhs MINUSMINUS
    (99) assign -> . PLUSPLUS lhs
    (100) assign -> . MINUSMINUS lhs
    (87) method_invocation -> . field_access LPAREN arguments RPAREN
    (88) method_invocation -> . field_access LPAREN RPAREN
    (118) empty -> .
    (22) type -> . INT
    (23) type -> . FLOAT
    (24) type -> . BOOLEAN
    (25) type -> . STRING
    (26) type -> . ID
    (84) lhs -> . field_access
    (85) field_access -> . primary DOT ID
    (86) field_access -> . ID
    (74) primary -> . literal
    (75) primary -> . THIS
    (76) primary -> . SUPER
    (77) primary -> . LPAREN expression RPAREN
    (78) primary -> . NEW ID LPAREN RPAREN
    (79) primary -> . NEW ID LPAREN arguments RPAREN
    (80) primary -> . method_invocation
    (81) primary -> . lhs
    (68) literal -> . INTEGER
    (69) literal -> . FLOAT
    (70) literal -> . STRING_LITERAL
    (71) literal -> . NULL
    (72) literal -> . FALSE
    (73) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for PLUSPLUS resolved as shift
  ! shift/reduce conflict for MINUSMINUS resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 76
    WHILE           shift and go to state 78
    FOR             shift and go to state 79
    RETURN          shift and go to state 82
    BREAK           shift and go to state 83
    CONTINUE        shift and go to state 84
    SEMICOLON       shift and go to state 81
    LCURLY          shift and go to state 58
    PLUSPLUS        shift and go to state 91
    MINUSMINUS      shift and go to state 92
    ELSE            reduce using rule 118 (empty -> .)
    RCURLY          reduce using rule 118 (empty -> .)
    INT             shift and go to state 23
    FLOAT           shift and go to state 94
    BOOLEAN         shift and go to state 25
    STRING          shift and go to state 26
    ID              shift and go to state 95
    THIS            shift and go to state 98
    SUPER           shift and go to state 99
    LPAREN          shift and go to state 77
    NEW             shift and go to state 100
    INTEGER         shift and go to state 101
    STRING_LITERAL  shift and go to state 102
    NULL            shift and go to state 103
    FALSE           shift and go to state 104
    TRUE            shift and go to state 105

  ! IF              [ reduce using rule 118 (empty -> .) ]
  ! WHILE           [ reduce using rule 118 (empty -> .) ]
  ! FOR             [ reduce using rule 118 (empty -> .) ]
  ! RETURN          [ reduce using rule 118 (empty -> .) ]
  ! BREAK           [ reduce using rule 118 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 118 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 118 (empty -> .) ]
  ! LCURLY          [ reduce using rule 118 (empty -> .) ]
  ! PLUSPLUS        [ reduce using rule 118 (empty -> .) ]
  ! MINUSMINUS      [ reduce using rule 118 (empty -> .) ]
  ! INT             [ reduce using rule 118 (empty -> .) ]
  ! FLOAT           [ reduce using rule 118 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 118 (empty -> .) ]
  ! STRING          [ reduce using rule 118 (empty -> .) ]
  ! ID              [ reduce using rule 118 (empty -> .) ]
  ! THIS            [ reduce using rule 118 (empty -> .) ]
  ! SUPER           [ reduce using rule 118 (empty -> .) ]
  ! LPAREN          [ reduce using rule 118 (empty -> .) ]
  ! NEW             [ reduce using rule 118 (empty -> .) ]
  ! INTEGER         [ reduce using rule 118 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 118 (empty -> .) ]
  ! NULL            [ reduce using rule 118 (empty -> .) ]
  ! FALSE           [ reduce using rule 118 (empty -> .) ]
  ! TRUE            [ reduce using rule 118 (empty -> .) ]

    stmt_expression                shift and go to state 80
    stmt                           shift and go to state 224
    block                          shift and go to state 85
    var_decl                       shift and go to state 86
    assign                         shift and go to state 87
    method_invocation              shift and go to state 88
    empty                          shift and go to state 59
    type                           shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 93
    primary                        shift and go to state 96
    literal                        shift and go to state 97

state 222

    (53) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .

    RCURLY          reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    IF              reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    WHILE           reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    FOR             reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    RETURN          reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    BREAK           reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    CONTINUE        reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    SEMICOLON       reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    LCURLY          reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    PLUSPLUS        reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    MINUSMINUS      reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    INT             reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    FLOAT           reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    BOOLEAN         reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    STRING          reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    ID              reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    THIS            reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    SUPER           reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    LPAREN          reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    NEW             reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    INTEGER         reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    STRING_LITERAL  reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    NULL            reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    FALSE           reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    TRUE            reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)
    ELSE            reduce using rule 53 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON RPAREN stmt .)


state 223

    (55) stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .

    RCURLY          reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    IF              reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    WHILE           reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    FOR             reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    RETURN          reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    BREAK           reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    CONTINUE        reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    SEMICOLON       reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    LCURLY          reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    PLUSPLUS        reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    MINUSMINUS      reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    INT             reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    FLOAT           reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    BOOLEAN         reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    STRING          reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    ID              reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    THIS            reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    SUPER           reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    LPAREN          reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    NEW             reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    INTEGER         reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    STRING_LITERAL  reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    NULL            reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    FALSE           reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    TRUE            reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    ELSE            reduce using rule 55 (stmt -> FOR LPAREN SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)


state 224

    (52) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .

    RCURLY          reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    IF              reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    WHILE           reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    FOR             reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    RETURN          reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    BREAK           reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    CONTINUE        reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    SEMICOLON       reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    LCURLY          reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    PLUSPLUS        reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    MINUSMINUS      reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    INT             reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    FLOAT           reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    BOOLEAN         reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    STRING          reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    ID              reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    THIS            reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    SUPER           reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    LPAREN          reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    NEW             reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    INTEGER         reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    STRING_LITERAL  reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    NULL            reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    FALSE           reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    TRUE            reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    ELSE            reduce using rule 52 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 8 resolved as shift
WARNING: shift/reduce conflict for VOID in state 8 resolved as shift
WARNING: shift/reduce conflict for INT in state 8 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 8 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 8 resolved as shift
WARNING: shift/reduce conflict for STRING in state 8 resolved as shift
WARNING: shift/reduce conflict for ID in state 11 resolved as shift
WARNING: shift/reduce conflict for VOID in state 11 resolved as shift
WARNING: shift/reduce conflict for INT in state 11 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 11 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 11 resolved as shift
WARNING: shift/reduce conflict for STRING in state 11 resolved as shift
WARNING: shift/reduce conflict for ID in state 43 resolved as shift
WARNING: shift/reduce conflict for VOID in state 43 resolved as shift
WARNING: shift/reduce conflict for INT in state 43 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 43 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 43 resolved as shift
WARNING: shift/reduce conflict for STRING in state 43 resolved as shift
WARNING: shift/reduce conflict for ID in state 56 resolved as shift
WARNING: shift/reduce conflict for VOID in state 56 resolved as shift
WARNING: shift/reduce conflict for INT in state 56 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 56 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 56 resolved as shift
WARNING: shift/reduce conflict for STRING in state 56 resolved as shift
WARNING: shift/reduce conflict for IF in state 58 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 58 resolved as shift
WARNING: shift/reduce conflict for FOR in state 58 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 58 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 58 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 58 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 58 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 58 resolved as shift
WARNING: shift/reduce conflict for PLUSPLUS in state 58 resolved as shift
WARNING: shift/reduce conflict for MINUSMINUS in state 58 resolved as shift
WARNING: shift/reduce conflict for INT in state 58 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 58 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 58 resolved as shift
WARNING: shift/reduce conflict for STRING in state 58 resolved as shift
WARNING: shift/reduce conflict for ID in state 58 resolved as shift
WARNING: shift/reduce conflict for THIS in state 58 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 58 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 58 resolved as shift
WARNING: shift/reduce conflict for NEW in state 58 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 58 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 58 resolved as shift
WARNING: shift/reduce conflict for NULL in state 58 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 58 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 58 resolved as shift
WARNING: shift/reduce conflict for RCURLY in state 74 resolved as shift
WARNING: shift/reduce conflict for IF in state 74 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 74 resolved as shift
WARNING: shift/reduce conflict for FOR in state 74 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 74 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 74 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 74 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 74 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 74 resolved as shift
WARNING: shift/reduce conflict for PLUSPLUS in state 74 resolved as shift
WARNING: shift/reduce conflict for MINUSMINUS in state 74 resolved as shift
WARNING: shift/reduce conflict for INT in state 74 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 74 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 74 resolved as shift
WARNING: shift/reduce conflict for STRING in state 74 resolved as shift
WARNING: shift/reduce conflict for ID in state 74 resolved as shift
WARNING: shift/reduce conflict for THIS in state 74 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 74 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 74 resolved as shift
WARNING: shift/reduce conflict for NEW in state 74 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 74 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 74 resolved as shift
WARNING: shift/reduce conflict for NULL in state 74 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 74 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 74 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 171 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 171 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 171 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 171 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 171 resolved as shift
WARNING: shift/reduce conflict for LESS in state 171 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 171 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 171 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 171 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 171 resolved as shift
WARNING: shift/reduce conflict for AND in state 171 resolved as shift
WARNING: shift/reduce conflict for OR in state 171 resolved as shift
WARNING: shift/reduce conflict for IF in state 184 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 184 resolved as shift
WARNING: shift/reduce conflict for FOR in state 184 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 184 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 184 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 184 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 184 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 184 resolved as shift
WARNING: shift/reduce conflict for PLUSPLUS in state 184 resolved as shift
WARNING: shift/reduce conflict for MINUSMINUS in state 184 resolved as shift
WARNING: shift/reduce conflict for INT in state 184 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 184 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 184 resolved as shift
WARNING: shift/reduce conflict for STRING in state 184 resolved as shift
WARNING: shift/reduce conflict for ID in state 184 resolved as shift
WARNING: shift/reduce conflict for THIS in state 184 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 184 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 184 resolved as shift
WARNING: shift/reduce conflict for NEW in state 184 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 184 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 184 resolved as shift
WARNING: shift/reduce conflict for NULL in state 184 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 184 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 184 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 185 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 185 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 185 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 185 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 185 resolved as shift
WARNING: shift/reduce conflict for LESS in state 185 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 185 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 185 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 185 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 185 resolved as shift
WARNING: shift/reduce conflict for AND in state 185 resolved as shift
WARNING: shift/reduce conflict for OR in state 185 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 186 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 186 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 186 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 186 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 186 resolved as shift
WARNING: shift/reduce conflict for LESS in state 186 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 186 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 186 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 186 resolved as shift
WARNING: shift/reduce conflict for AND in state 186 resolved as shift
WARNING: shift/reduce conflict for OR in state 186 resolved as shift
WARNING: shift/reduce conflict for IF in state 187 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 187 resolved as shift
WARNING: shift/reduce conflict for FOR in state 187 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 187 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 187 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 187 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 187 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 187 resolved as shift
WARNING: shift/reduce conflict for PLUSPLUS in state 187 resolved as shift
WARNING: shift/reduce conflict for MINUSMINUS in state 187 resolved as shift
WARNING: shift/reduce conflict for INT in state 187 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 187 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 187 resolved as shift
WARNING: shift/reduce conflict for STRING in state 187 resolved as shift
WARNING: shift/reduce conflict for ID in state 187 resolved as shift
WARNING: shift/reduce conflict for THIS in state 187 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 187 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 187 resolved as shift
WARNING: shift/reduce conflict for NEW in state 187 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 187 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 187 resolved as shift
WARNING: shift/reduce conflict for NULL in state 187 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 187 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 187 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 195 resolved as shift
WARNING: shift/reduce conflict for IF in state 200 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 200 resolved as shift
WARNING: shift/reduce conflict for FOR in state 200 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 200 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 200 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 200 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 200 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 200 resolved as shift
WARNING: shift/reduce conflict for PLUSPLUS in state 200 resolved as shift
WARNING: shift/reduce conflict for MINUSMINUS in state 200 resolved as shift
WARNING: shift/reduce conflict for INT in state 200 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 200 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 200 resolved as shift
WARNING: shift/reduce conflict for STRING in state 200 resolved as shift
WARNING: shift/reduce conflict for ID in state 200 resolved as shift
WARNING: shift/reduce conflict for THIS in state 200 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 200 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 200 resolved as shift
WARNING: shift/reduce conflict for NEW in state 200 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 200 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 200 resolved as shift
WARNING: shift/reduce conflict for NULL in state 200 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 200 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 200 resolved as shift
WARNING: shift/reduce conflict for IF in state 204 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 204 resolved as shift
WARNING: shift/reduce conflict for FOR in state 204 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 204 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 204 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 204 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 204 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 204 resolved as shift
WARNING: shift/reduce conflict for PLUSPLUS in state 204 resolved as shift
WARNING: shift/reduce conflict for MINUSMINUS in state 204 resolved as shift
WARNING: shift/reduce conflict for INT in state 204 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 204 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 204 resolved as shift
WARNING: shift/reduce conflict for STRING in state 204 resolved as shift
WARNING: shift/reduce conflict for ID in state 204 resolved as shift
WARNING: shift/reduce conflict for THIS in state 204 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 204 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 204 resolved as shift
WARNING: shift/reduce conflict for NEW in state 204 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 204 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 204 resolved as shift
WARNING: shift/reduce conflict for NULL in state 204 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 204 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 204 resolved as shift
WARNING: shift/reduce conflict for IF in state 206 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 206 resolved as shift
WARNING: shift/reduce conflict for FOR in state 206 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 206 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 206 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 206 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 206 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 206 resolved as shift
WARNING: shift/reduce conflict for PLUSPLUS in state 206 resolved as shift
WARNING: shift/reduce conflict for MINUSMINUS in state 206 resolved as shift
WARNING: shift/reduce conflict for INT in state 206 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 206 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 206 resolved as shift
WARNING: shift/reduce conflict for STRING in state 206 resolved as shift
WARNING: shift/reduce conflict for ID in state 206 resolved as shift
WARNING: shift/reduce conflict for THIS in state 206 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 206 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 206 resolved as shift
WARNING: shift/reduce conflict for NEW in state 206 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 206 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 206 resolved as shift
WARNING: shift/reduce conflict for NULL in state 206 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 206 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 206 resolved as shift
WARNING: shift/reduce conflict for IF in state 208 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 208 resolved as shift
WARNING: shift/reduce conflict for FOR in state 208 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 208 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 208 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 208 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 208 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 208 resolved as shift
WARNING: shift/reduce conflict for PLUSPLUS in state 208 resolved as shift
WARNING: shift/reduce conflict for MINUSMINUS in state 208 resolved as shift
WARNING: shift/reduce conflict for INT in state 208 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 208 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 208 resolved as shift
WARNING: shift/reduce conflict for STRING in state 208 resolved as shift
WARNING: shift/reduce conflict for ID in state 208 resolved as shift
WARNING: shift/reduce conflict for THIS in state 208 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 208 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 208 resolved as shift
WARNING: shift/reduce conflict for NEW in state 208 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 208 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 208 resolved as shift
WARNING: shift/reduce conflict for NULL in state 208 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 208 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 208 resolved as shift
WARNING: shift/reduce conflict for IF in state 211 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 211 resolved as shift
WARNING: shift/reduce conflict for FOR in state 211 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 211 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 211 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 211 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 211 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 211 resolved as shift
WARNING: shift/reduce conflict for PLUSPLUS in state 211 resolved as shift
WARNING: shift/reduce conflict for MINUSMINUS in state 211 resolved as shift
WARNING: shift/reduce conflict for INT in state 211 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 211 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 211 resolved as shift
WARNING: shift/reduce conflict for STRING in state 211 resolved as shift
WARNING: shift/reduce conflict for ID in state 211 resolved as shift
WARNING: shift/reduce conflict for THIS in state 211 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 211 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 211 resolved as shift
WARNING: shift/reduce conflict for NEW in state 211 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 211 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 211 resolved as shift
WARNING: shift/reduce conflict for NULL in state 211 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 211 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 211 resolved as shift
WARNING: shift/reduce conflict for IF in state 213 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 213 resolved as shift
WARNING: shift/reduce conflict for FOR in state 213 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 213 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 213 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 213 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 213 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 213 resolved as shift
WARNING: shift/reduce conflict for PLUSPLUS in state 213 resolved as shift
WARNING: shift/reduce conflict for MINUSMINUS in state 213 resolved as shift
WARNING: shift/reduce conflict for INT in state 213 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 213 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 213 resolved as shift
WARNING: shift/reduce conflict for STRING in state 213 resolved as shift
WARNING: shift/reduce conflict for ID in state 213 resolved as shift
WARNING: shift/reduce conflict for THIS in state 213 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 213 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 213 resolved as shift
WARNING: shift/reduce conflict for NEW in state 213 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 213 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 213 resolved as shift
WARNING: shift/reduce conflict for NULL in state 213 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 213 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 213 resolved as shift
WARNING: shift/reduce conflict for IF in state 216 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 216 resolved as shift
WARNING: shift/reduce conflict for FOR in state 216 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 216 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 216 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 216 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 216 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 216 resolved as shift
WARNING: shift/reduce conflict for PLUSPLUS in state 216 resolved as shift
WARNING: shift/reduce conflict for MINUSMINUS in state 216 resolved as shift
WARNING: shift/reduce conflict for INT in state 216 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 216 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 216 resolved as shift
WARNING: shift/reduce conflict for STRING in state 216 resolved as shift
WARNING: shift/reduce conflict for ID in state 216 resolved as shift
WARNING: shift/reduce conflict for THIS in state 216 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 216 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 216 resolved as shift
WARNING: shift/reduce conflict for NEW in state 216 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 216 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 216 resolved as shift
WARNING: shift/reduce conflict for NULL in state 216 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 216 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 216 resolved as shift
WARNING: shift/reduce conflict for IF in state 218 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 218 resolved as shift
WARNING: shift/reduce conflict for FOR in state 218 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 218 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 218 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 218 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 218 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 218 resolved as shift
WARNING: shift/reduce conflict for PLUSPLUS in state 218 resolved as shift
WARNING: shift/reduce conflict for MINUSMINUS in state 218 resolved as shift
WARNING: shift/reduce conflict for INT in state 218 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 218 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 218 resolved as shift
WARNING: shift/reduce conflict for STRING in state 218 resolved as shift
WARNING: shift/reduce conflict for ID in state 218 resolved as shift
WARNING: shift/reduce conflict for THIS in state 218 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 218 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 218 resolved as shift
WARNING: shift/reduce conflict for NEW in state 218 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 218 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 218 resolved as shift
WARNING: shift/reduce conflict for NULL in state 218 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 218 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 218 resolved as shift
WARNING: shift/reduce conflict for IF in state 221 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 221 resolved as shift
WARNING: shift/reduce conflict for FOR in state 221 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 221 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 221 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 221 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 221 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 221 resolved as shift
WARNING: shift/reduce conflict for PLUSPLUS in state 221 resolved as shift
WARNING: shift/reduce conflict for MINUSMINUS in state 221 resolved as shift
WARNING: shift/reduce conflict for INT in state 221 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 221 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 221 resolved as shift
WARNING: shift/reduce conflict for STRING in state 221 resolved as shift
WARNING: shift/reduce conflict for ID in state 221 resolved as shift
WARNING: shift/reduce conflict for THIS in state 221 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 221 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 221 resolved as shift
WARNING: shift/reduce conflict for NEW in state 221 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 221 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 221 resolved as shift
WARNING: shift/reduce conflict for NULL in state 221 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 221 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 221 resolved as shift
